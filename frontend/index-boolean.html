<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none }
    a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:auto; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
    .grid > .card.wide { grid-column: 1 / -1; }
    /* Let Result span both columns when .wide is applied */
.grid > .card.wide { grid-column: 1 / -1; }

/* Ensure big SVGs aren’t clamped */
#result svg { max-height: none !important; width: 100%; height: auto; }

/* (optional) give the Result card more breathing room */
aside.card.wide { padding-block: 24px; }

  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses. Implicit AND allowed, e.g., <b>AB + A~C</b>. K-map commands: <b>kmap A,B,C : Σm(1,3,5)</b> or <b>kmap A,B : ΠM(0,2)</b>, or <b>kmap A,B,C : AB + A'C</b>.</p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>
          <button class="btn secondary" id="btnCircuit">Circuit</button>
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>
          <button class="btn secondary" id="btnKmapGroups">K-map Pairings &amp; Solution</button>
          <button class="btn secondary" id="btnClear">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>

<script type="module">
  const API = "https://polycode-ba.onrender.com";
  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");
  const gray = n => n ^ (n >> 1);

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = ""; varsEl.value = "";
    resEl.innerHTML = ""; ttCard.style.display = "none"; ttEl.innerHTML = "";
  });

  /* ---------- KMAP PARSING (Σ / Π / expr) ---------- */
  function parseKmapCommand(s){
    const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
    if (!mHdr) return null;

    const vars = mHdr[1].split(",").map(x=>x.trim());
    let rhs = mHdr[2].trim();

    // Optional don't-cares: ; d(…)
    let dontCares = [];
    const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
    if (mDC) { dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite); rhs = rhs.slice(0, mDC.index).trim(); }

    const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
    const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
    const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

    if (reSigma.test(rhs)) {
      const mm = reSigma.exec(rhs);
      const minterms = parseList(mm[1]);
      return { vars, mode:"ones", minterms, dontCares };
    }
    if (rePi.test(rhs)) {
      const mm = rePi.exec(rhs);
      const maxterms = parseList(mm[1]);
      const n = vars.length, U = Array.from({length:1<<n},(_,i)=>i);
      const bad = new Set([...maxterms, ...dontCares]);
      const minterms = U.filter(i => !bad.has(i));                      // for grid display
      return { vars, mode:"zeros", maxterms, minterms, dontCares };
    }
    if (/^[0-9,\s]+$/.test(rhs)) {
      const minterms = parseList(rhs);
      return { vars, mode:"ones", minterms, dontCares };
    }
    return { vars, expr: rhs, dontCares };
  }

  /* ---------- BASIC GRID (compact HTML table) ---------- */
  function renderKmapTable(vars, minterms){
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;

    const grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
    for (let i=0; i<(1<<n); i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const rowLabels = Array.from({length:rows}, (_,r)=>(gray(r)>>>0).toString(2).padStart(rbits,'0'));
    const colLabels = Array.from({length:cols}, (_,c)=>(gray(c)>>>0).toString(2).padStart(cbits,'0'));

    const head =
      `<tr><th>${vars.slice(0,rbits).join("") || "&nbsp;"}</th>` +
      colLabels.map(l=>`<th>${vars.slice(rbits).join("")? vars.slice(rbits).join("")+"="+l : l}</th>`).join("") + `</tr>`;
    const body = grid.map((row,r) =>
      `<tr><th>${vars.slice(0,rbits).join("")? vars.slice(0,rbits).join("")+"="+rowLabels[r] : rowLabels[r]}</th>` +
      row.map(v=>`<td>${v}</td>`).join("") + `</tr>`
    ).join("");

    resEl.innerHTML = `
      <div class="mono">K-map (${n} vars): ${vars.join(", ")}</div>
      <table style="margin-top:8px"><thead>${head}</thead><tbody>${body}</tbody></table>
      <div class="muted" style="margin-top:8px">Tip: groups are powers of 2; wrap edges.</div>
    `;
  }

  /* ---------- BIG SVG KMAP WITH GROUPS ---------- */
  function renderKmapSVG(vars, minterms, groups = [], title = "K-map", opts = {}) {
    const mode   = opts.mode ?? "ones";
    const scale  = opts.scale ?? 2.2;
    const cellW  = Math.round(42 * scale);
    const cellH  = Math.round(30 * scale);
    const pad    = Math.round(24 * scale);
    const font14 = Math.round(14 * scale);
    const font12 = Math.round(12 * scale);

    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;

    const grid = Array.from({length:rows},()=>Array(cols).fill(0));
    for (let i=0;i<(1<<n);i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const W = pad*2 + cols*cellW + 100, H = pad*2 + rows*cellH + 40;

    const rects = groups.map(g=>{
      const x = pad + g.c*cellW, y = pad + g.r*cellH;
      const w = g.wr*cellW,      h = g.hr*cellH;
      const dash = (mode === "zeros") ? ` stroke-dasharray="${Math.round(6*scale)} ${Math.round(4*scale)}"` : "";
      return `<rect x="${x+2}" y="${y+2}" width="${w-4}" height="${h-4}" rx="${Math.round(8*scale)}"
                     fill="none" stroke="currentColor" stroke-width="2"${dash}
                     vector-effect="non-scaling-stroke"/>`;
    }).join("");

    const cells = grid.map((row,ri)=>
      row.map((v,ci)=>{
        const x = pad + ci*cellW, y = pad + ri*cellH;
        return `<rect x="${x}" y="${y}" width="${cellW}" height="${cellH}" fill="none" stroke="currentColor" opacity="0.35"/>
                <text x="${x+cellW/2}" y="${y+cellH/2+font14/3}" text-anchor="middle"
                      class="mono" font-size="${font14}" fill="currentColor">${v}</text>`;
      }).join("")
    ).join("");

    const colLbl = Array.from({length:cols},(_,c)=> (gray(c)>>>0).toString(2).padStart(cbits,'0'))
      .map((l,i)=>`<text x="${pad + i*cellW + cellW/2}" y="${pad-6}" text-anchor="middle"
                       class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");
    const rowLbl = Array.from({length:rows},(_,r)=> (gray(r)>>>0).toString(2).padStart(rbits,'0'))
      .map((l,i)=>`<text x="${pad-6}" y="${pad + i*cellH + cellH/2+font12/3}"
                       text-anchor="end" class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");

    const subtitle = (mode === "zeros")
      ? `<div class="muted mono">Mode: POS — groups on 0-cells (dashed)</div>`
      : `<div class="muted mono">Mode: SOP — groups on 1-cells</div>`;

    return `<div class="mono" style="margin:.5rem 0 .25rem">${title}</div>
            ${subtitle}
            <svg viewBox="0 0 ${W} ${H}" width="100%">
              <g fill="none" stroke="currentColor">${cells}${rects}</g>
              <g fill="currentColor">${colLbl}${rowLbl}</g>
            </svg>`;
  }

  /* ---------- SIMPLIFY button ---------- */
  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    // K-map command?
    const km = parseKmapCommand(text);
    if (km) {
      ttCard.style.display = "none"; ttEl.innerHTML = "";
      resEl.textContent = "Building K-map…";
      try {
        // If user gave an expr after "kmap", get minterms to draw the grid with F-values
        let minForGrid = km.minterms;
        if (km.expr) {
          const r1 = await fetch(API + "/api/ba/simplify", {
            method:"POST", headers:{ "Content-Type":"application/json" },
            body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
          });
          const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error || "simplify error");
          minForGrid = j1.minterms;
        }
        renderKmapTable(km.vars, minForGrid);
      } catch (e) {
        resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      }
      return;
    }

    // Otherwise, normal simplify flow
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else {
        ttCard.style.display="none"; ttEl.innerHTML="";
      }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });

  /* ---------- CIRCUIT SVG (ANSI/IEC shapes, fit-to-width, caption) ---------- */
// Orthogonal (Manhattan) circuit renderer with barycenter ordering + fit-to-width
// -----------------------------------------------------------------------------
// Manhattan (90°) logic renderer with Sugiyama-style layout:
// - Splits long edges into per-layer "WIRE" nodes
// - 4 barycenter sweeps (forward + reverse) to reduce crossings
// - Orthogonal H-V-H routing with per-input vertical tracks
// - Fit-to-width scaling (opts.scale='fit', opts.fitWidth)
// -----------------------------------------------------------------------------
// Manhattan, color-coded logic renderer with barycenter ordering + wire splitting
function renderCircuitSVG(net, opts = {}) {
  const caption = opts.caption ?? "";
  let   scale   = opts.scale ?? 'fit';          // 'fit' or number
  const fitW    = opts.fitWidth ?? 1000;
  const zoom    = opts.zoom ?? 1.6;             // extra size multiplier

  // Base geometry (pre-scale)
  const GW0=72, GH0=46, PIN0=10, XSTEP0=180, YSTEP0=100, PAD0=28;

  // --- Shapes (ANSI/IEC-ish), no inline fill (CSS colors will paint them) ---
  const bubble = (x, y, s) =>
    `<circle cx="${x}" cy="${y}" r="${Math.round(6*s)}" stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;

  const gateAND = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const r = GH/2, xr = x + GW - r;
    return `<path d="M${x},${y} H${xr} A${r},${r} 0 0 1 ${xr},${y+GH} H${x} Z" stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
  };
  const gateOR = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const xIn = x + Math.round(14*s), xOut = x + GW - Math.round(10*s);
    const xm  = x + GW - Math.round(22*s), b = y + GH;
    return `<path d="M${xIn},${y}
                     C ${xm-22},${y} ${xm},${y+GH/2} ${xOut},${y+GH/2}
                     C ${xm},${y+GH/2} ${xm-22},${b} ${xIn},${b}
                     C ${x+6},${b-10} ${x+6},${y+10} ${xIn},${y}"
             stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
  };
  const gateXOR = (x, y, s) => {
    const or = gateOR(x, y, s);
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const xIn = x + Math.round(8*s), xm = x + GW - Math.round(22*s), b=y+GH;
    const extra = `<path d="M${xIn},${y} C ${xm-22},${y} ${xm},${y+GH/2} ${xIn},${b}"
                   stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
    return or + extra;
  };
  const gateNOT = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const tri = `<path d="M${x},${y} L${x},${y+GH} L${x+GW-12},${y+GH/2} Z"
                 stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
    return tri + bubble(x + GW - 4*s, y + GH/2, s);
  };

  // --- Build graph with succ/pred maps ---
  const nodes = new Map(), succ = new Map(), pred = new Map();
  const addNode = n => { nodes.set(n.id, n); succ.has(n.id)||succ.set(n.id,[]); pred.has(n.id)||pred.set(n.id,[]); };

  net.gates.forEach(g => addNode({...g}));
  net.inputs.forEach(i => addNode({ id:i.id, type:"IN", ins:[], label:i.label }));
  addNode({ id: net.output, type: nodes.get(net.output)?.type || "OUT", ins: nodes.get(net.output)?.ins || [] });

  nodes.forEach(n => (n.ins||[]).forEach(p => { if(!nodes.has(p)) addNode({id:p,type:"WIRE",ins:[]}); succ.get(p).push(n.id); pred.get(n.id).push(p); }));

  // --- Initial layering: longest path from inputs
  const level = new Map();
  const lev = id => level.has(id) ? level.get(id) :
    level.set(id, (["IN","VCC","GND"].includes(nodes.get(id)?.type)||id==="VCC_1"||id==="GND_0") ? 0 : Math.max(0,...(pred.get(id)||[]).map(lev))+1).get(id);
  nodes.forEach((_,id)=>lev(id));

  // --- Split long edges into per-layer wire nodes
  let wireSerial=0; const wid=()=>`_W${wireSerial++}`;
  pred.forEach((parents, child)=>{
    const lc=level.get(child);
    parents.slice().forEach(p=>{
      const lp=level.get(p);
      if (lc-lp<=1) return;
      succ.set(p,(succ.get(p)||[]).filter(x=>x!==child));
      pred.set(child,(pred.get(child)||[]).filter(x=>x!==p));
      let prev=p;
      for (let L=lp+1; L<lc; L++){
        const w=wid(); addNode({id:w,type:"WIRE",ins:[prev]}); level.set(w,L);
        succ.get(prev).push(w); pred.get(w).push(prev); prev=w;
      }
      succ.get(prev).push(child); pred.get(child).push(prev);
    });
  });

  // --- Layers array
  let layers=[]; level.forEach((v,id)=> (layers[v]||(layers[v]=[])).push(id));

  // --- Barycenter ordering (forward+reverse, 4 sweeps)
  const pos = new Map(); const recompute=()=>{ pos.clear(); layers.forEach((ids,L)=>ids.forEach((id,i)=>pos.set(id,i))); };
  const avg = arr => arr.length ? arr.reduce((a,b)=>a+(pos.get(b)||0),0)/arr.length : -1e9;

  const sweepF=()=>{ for(let L=1;L<layers.length;L++){ layers[L].sort((a,b)=>avg(pred.get(a)||[])-avg(pred.get(b)||[])||a.localeCompare(b)); } };
  const sweepR=()=>{ for(let L=layers.length-2;L>=0;L--){ layers[L].sort((a,b)=>avg(succ.get(a)||[])-avg(succ.get(b)||[])||a.localeCompare(b)); } };
  for(let i=0;i<4;i++){ sweepF(); recompute(); sweepR(); recompute(); } recompute();

  // --- Fit scale
  if (scale==='fit') {
    const baseW = (layers.length+1)*XSTEP0 + 2*PAD0;
    scale = Math.max(1.15, (fitW*zoom) / baseW);
  }
  const s=+scale, GW=Math.round(GW0*s), GH=Math.round(GH0*s), PIN=Math.round(PIN0*s);
  const XSTEP=Math.round(XSTEP0*s), YSTEP=Math.round(YSTEP0*s), PAD=Math.round(PAD0*s);

  const abs = new Map(); layers.forEach((ids,lx)=>ids.forEach((id,ly)=>abs.set(id,{x:PAD+lx*XSTEP,y:PAD+ly*YSTEP})));
  const width  = (layers.length+1)*XSTEP + 2*PAD;
  const height = Math.max(1,...layers.map(a=>a.length))*YSTEP + 2*PAD + (caption?Math.round(28*s):0);

  const pinY = (y,n,k)=> y + GH*((k+1)/(Math.max(1,n)+1));

  // --- Gate glyphs with per-type color classes
  function drawGate(n){
    if (n.type==="WIRE") return "";
    const p=abs.get(n.id); const nIns=(n.ins||[]).length||1;
    const pins = Array.from({length:nIns},(_,k)=>`<line x1="${p.x-PIN}" y1="${pinY(p.y,nIns,k)}" x2="${p.x}" y2="${pinY(p.y,nIns,k)}"/>`).join("");
    const wrap = (cls,body)=>`<g class="gate ${cls}" color="currentColor">${pins}${body}</g>`;
    if (n.type==="IN"){
      const w=Math.round(58*s), h=Math.round(26*s), r=Math.round(6*s);
      return `<g class="gate IN"><rect x="${p.x}" y="${p.y}" width="${w}" height="${h}" rx="${r}"/>
              <text x="${p.x+w/2}" y="${p.y+h/2+6}" text-anchor="middle" class="mono">${n.label||n.id}</text></g>`;
    }
    if (n.type==="NOT")  return wrap("NOT",  gateNOT(p.x,p.y,s));
    if (n.type==="AND")  return wrap("AND",  gateAND(p.x,p.y,s));
    if (n.type==="OR")   return wrap("OR",   gateOR(p.x,p.y,s));
    if (n.type==="XOR")  return wrap("XOR",  gateXOR(p.x,p.y,s));
    if (n.type==="NAND") return wrap("NAND", gateAND(p.x,p.y,s) + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
    if (n.type==="NOR")  return wrap("NOR",  gateOR(p.x,p.y,s)  + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
    if (n.type==="XNOR") return wrap("XNOR", gateXOR(p.x,p.y,s) + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
    return wrap("OTHER", `<rect x="${p.x}" y="${p.y}" width="${GW}" height="${GH}" rx="${Math.round(10*s)}"/>
                          <text x="${p.x+GW/2}" y="${p.y+GH/2+5}" text-anchor="middle" class="mono">${n.type}</text>`);
  }

  // --- Orthogonal H-V-H wires with per-input tracks
  function wiresTo(tid){
    const t = nodes.get(tid), dst = abs.get(tid);
    const xL = dst.x, yT = dst.y, ins = (t.ins||[]);
    return ins.map((sid,k)=>{
      const sp = abs.get(sid) || {x:xL - XSTEP/2, y:yT};
      const x1 = sp.x + GW, y1 = sp.y + GH/2;
      const x2 = xL,        y2 = pinY(yT, ins.length||1, k);
      const track = Math.round(22*s);
      const bendX = x2 - Math.round(GW/4) - (k+1)*track;
      return `M${x1},${y1} H${bendX} V${y2} H${x2}`;
    }).join(" ");
  }
  const wiresSVG = Array.from(nodes.values()).filter(n=>(n.ins||[]).length).map(n=>`<path d="${wiresTo(n.id)}" class="wire"/>`).join("");
  const gatesSVG = Array.from(nodes.values()).map(drawGate).join("");
  const outPos = abs.get(net.output) || { x: width-80, y: height/2 };

  // --- Embedded SVG style: color palette
  const style = `
  <style>
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: ${Math.max(12, Math.round(12*s))}px; }
    .wire { stroke: #aab4c0; stroke-width: ${Math.max(2.8, 2.8*s)}; stroke-linecap: round; stroke-linejoin: round; fill: none; }
    .gate line, .gate path, .gate rect { stroke-width: ${Math.max(2.8, 2.8*s)}; stroke-linecap: round; stroke-linejoin: round; }
    .gate.IN   rect { stroke:#B0BEC5; fill: rgba(176,190,197,0.10); }
    .gate.AND  path, .gate.AND rect  { stroke:#3DDC97; fill: rgba(61,220,151,0.12); }
    .gate.OR   path                 { stroke:#FFB86B; fill: rgba(255,184,107,0.12); }
    .gate.XOR  path                 { stroke:#FF79C6; fill: rgba(255,121,198,0.12); }
    .gate.NOT  path                 { stroke:#8BE9FD; fill: rgba(139,233,253,0.10); }
    .gate.NAND path, .gate.NAND rect{ stroke:#00C853; fill: rgba(0,200,83,0.12); }
    .gate.NOR  path                 { stroke:#FF7043; fill: rgba(255,112,67,0.12); }
    .gate.XNOR path                 { stroke:#8E44AD; fill: rgba(142,68,173,0.12); }
    .gate.OTHER rect                { stroke:#9aa4b2; fill: rgba(154,164,178,0.10); }
  </style>`;

  const captionSVG = caption ? `<text x="${PAD}" y="${height - Math.round(10*s)}" class="mono" fill="currentColor">F = ${caption}</text>` : "";

  return `<svg viewBox="0 0 ${width} ${height}" width="100%" preserveAspectRatio="xMinYMin meet">
    ${style}
    <g class="wires">${wiresSVG}</g>
    <g class="gates">${gatesSVG}</g>
    <g class="labels" fill="currentColor">
      ${captionSVG}
      <text x="${outPos.x + Math.round(90*s)}" y="${outPos.y + Math.round(24*s)}" class="mono">F</text>
    </g>
  </svg>`;
}












  

  const resultCard = document.querySelector("aside.card");

async function drawCircuit(style){
  const text = exprEl.value.trim();
  const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
  if (!text) { alert("Enter an expression"); return; }

  resEl.textContent = `Generating ${style.toUpperCase()} circuit…`;
  ttCard.style.display="none"; ttEl.innerHTML="";

  // 1) make the Result card span both columns
  resultCard?.classList.add("wide");

  // 2) fetch the netlist
  const r = await fetch(API + "/api/ba/netlist", {
    method:"POST", headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ expr: text, vars, style })
  });
  const j = await r.json();
  if (!j.ok) { resEl.innerHTML = `<span class="muted">Error: ${j.error}</span>`; return; }

  // 3) WAIT one frame so the card actually becomes wide → then measure
  requestAnimationFrame(() => {
    const fitWidth = resultCard.getBoundingClientRect().width - 32; // wide width
    resEl.innerHTML = renderCircuitSVG(j, {
      caption: exprEl.value.trim(),
      scale: 'fit',
      fitWidth,
      zoom: 2.2       // try 1.8–2.4 for even bigger
    });
  });
}


  $("#btnCircuit").addEventListener("click", () => drawCircuit("mixed"));
  $("#btnCircuitNAND").addEventListener("click", () => drawCircuit("nand"));
  $("#btnCircuitNOR").addEventListener("click", () => drawCircuit("nor"));

  /* ---------- KMAP Pairings & Solution (big SVG) ---------- */
  async function showKmapGroups() {
    const text = exprEl.value.trim();
    if (!text) { alert("Type a kmap command or an expression."); return; }

    let vars, mode="ones", minForGrid, body;

    const km = parseKmapCommand(text);
    if (km) {
      vars = km.vars;
      if (km.expr) {
        const r1 = await fetch(API + "/api/ba/simplify", {
          method:"POST", headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
        });
        const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
        minForGrid = j1.minterms;
        mode = "ones";
        body = { vars, minterms: minForGrid, full:true, mode };
      } else if (km.mode === "zeros") {
        vars = km.vars; mode = "zeros"; minForGrid = km.minterms;
        body = { vars, maxterms: km.maxterms, full:true, mode };
      } else {
        vars = km.vars; mode = "ones"; minForGrid = km.minterms;
        body = { vars, minterms: minForGrid, full:true, mode };
      }
    } else {
      // plain expression: compute minterms
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars: varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
      vars = j1.vars; minForGrid = j1.minterms; mode = "ones";
      body = { vars, minterms: minForGrid, full:true, mode };
    }

    const r2 = await fetch(API + "/api/ba/kmap", {
      method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body)
    });
    const j2 = await r2.json(); if (!j2.ok) { resEl.innerHTML = `<span class="muted">Error: ${j2.error}</span>`; return; }

    resEl.innerHTML =
      renderKmapSVG(vars, minForGrid,
        j2.allGroups.filter(g => g.hr*g.wr === 2),
        mode === "zeros" ? "All pairings (size 2) · POS (0-groups)" : "All pairings (size 2) · SOP",
        { mode, scale: 2.0 }) +
      renderKmapSVG(vars, minForGrid, j2.solutionGroups,
        mode === "zeros" ? `Solution (POS): ${j2.simplified}` : `Solution (SOP): ${j2.simplified}`,
        { mode, scale: 2.2 });
  }

  $("#btnKmapGroups").addEventListener("click", () => {
    ttCard.style.display="none"; ttEl.innerHTML="";
    resEl.textContent = "Analyzing K-map…";
    showKmapGroups().catch(e => resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`);
  });
</script>
</body>
</html>
