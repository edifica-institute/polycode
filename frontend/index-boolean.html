<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none }
    a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:100%; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses. Implicit AND allowed, e.g., <b>AB + A~C</b>.</p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>
          <button class="btn secondary" id="btnCircuit">Circuit</button>
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>

          <button class="btn secondary" id="btnClear">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>



<script type="module">
  const API = "https://polycode-ba.onrender.com";

  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = "";
    varsEl.value = "";
    resEl.innerHTML = "";
    ttCard.style.display = "none";
    ttEl.innerHTML = "";
  });

  const gray = n => n ^ (n >> 1);

function parseKmapCommand(s){
  // kmap <vars> [:|=] < list | Σm(...) | ΠM(...) | boolean expr > [ ; d(...) ]
  const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
  if (!mHdr) return null;

  const vars = mHdr[1].split(",").map(x=>x.trim());
  let rhs = mHdr[2].trim();

  // Optional don't-cares at end: ; d(...)
  let dontCares = [];
  const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
  if (mDC) {
    dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite);
    rhs = rhs.slice(0, mDC.index).trim();
  }

  const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
  const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
  const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

  // Σm(...)
  if (reSigma.test(rhs)) {
    const mm = reSigma.exec(rhs);
    return { vars, minterms: parseList(mm[1]), dontCares };
  }
  // ΠM(...) => convert to minterms (exclude don't-cares)
  if (rePi.test(rhs)) {
    const mm = rePi.exec(rhs);
    const maxterms = parseList(mm[1]);
    const n = vars.length;
    const universe = Array.from({length: 1<<n}, (_,i)=>i);
    const bad = new Set([...maxterms, ...dontCares]);
    return { vars, minterms: universe.filter(i => !bad.has(i)), dontCares };
  }
  // Plain list 1,2,3
  if (/^[0-9,\s]+$/.test(rhs)) {
    return { vars, minterms: parseList(rhs), dontCares };
  }
  // Otherwise treat as a boolean expression (e.g., AB + A'C)
  return { vars, expr: rhs, dontCares };
}



  function renderKmap(vars, minterms){
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1 << rbits, cols = 1 << cbits;

    const grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
    for (let i=0; i < (1<<n); i++){
      const r = gray(i >> cbits) & (rows - 1);
      const c = gray(i & ((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const rowLabels = Array.from({length:rows}, (_,r)=> (gray(r) >>> 0).toString(2).padStart(rbits,'0'));
    const colLabels = Array.from({length:cols}, (_,c)=> (gray(c) >>> 0).toString(2).padStart(cbits,'0'));

    const head =
      `<tr><th>${vars.slice(0,rbits).join("") || "&nbsp;"}</th>` +
      colLabels.map(l=>`<th>${vars.slice(rbits).join("")? vars.slice(rbits).join("")+"="+l : l}</th>`).join("") +
      `</tr>`;
    const body = grid.map((row,r) =>
      `<tr><th>${vars.slice(0,rbits).join("")? vars.slice(0,rbits).join("")+"="+rowLabels[r] : rowLabels[r]}</th>` +
      row.map(v=>`<td>${v}</td>`).join("") + `</tr>`
    ).join("");

    resEl.innerHTML = `
      <div class="mono">K-map (${n} vars): ${vars.join(", ")}</div>
      <div class="muted mono">Minterms: [${minterms.join(", ")}]</div>
      <table style="width:auto;border-collapse:collapse;margin-top:8px;font-size:14px">
        <thead>${head}</thead>
        <tbody>${body}</tbody>
      </table>
      <div class="muted" style="margin-top:8px">Tip: groups are powers of 2; wrap edges when grouping.</div>
    `;
  }

  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    // --- KMAP COMMAND? ---
    const km = parseKmapCommand(text);
if (km) {
  ttCard.style.display = "none"; ttEl.innerHTML = "";
  resEl.textContent = "Building K-map…";
  try {
    // NEW: if user gave an expression, get its minterms first
    let minterms = km.minterms;
    if (km.expr) {
      const r1 = await fetch(API + "/api/ba/simplify", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
      });
      const j1 = await r1.json();
      if (!j1.ok) throw new Error(j1.error || "simplify error");
      minterms = j1.minterms;
    }

    // Optional: ask backend for grouping hints (or skip and just render)
    /* const r2 = await fetch(API + "/api/ba/kmap", {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({ vars: km.vars, minterms })
       });
       const j2 = await r2.json();
       if (!j2.ok) throw new Error(j2.error || "kmap error");
    */

    renderKmap(km.vars, minterms);
  } catch (e) {
    resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
  }
  return;
}
    // --- OTHERWISE: normal simplify flow ---
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else {
        ttCard.style.display="none"; ttEl.innerHTML="";
      }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });



// dumb layout: layer by distance from inputs
function renderCircuitSVG(net){
  const inSet = new Set(net.inputs.map(i=>i.id));
  const fan = new Map(); // id -> list of users
  const nodes = new Map(); // id -> {id,type,ins,label}
  for (const g of net.gates){ nodes.set(g.id, {...g}); for (const i of g.ins){ (fan.get(i)||fan.set(i,[]),fan.get(i)).push(g.id);} }
  for (const i of net.inputs) nodes.set(i.id, { id:i.id, type:"IN", ins:[], label:i.label });
  nodes.set(net.output, nodes.get(net.output)||{id:net.output, type:"OUT", ins:[]});

  // level = longest path from any input
  const level = new Map();
  function lev(id){
    if (level.has(id)) return level.get(id);
    const n = nodes.get(id);
    const v = (n.type==="IN" || id==="VCC_1" || id==="GND_0") ? 0 : Math.max(0, ...(n.ins||[]).map(lev)) + 1;
    level.set(id, v); return v;
  }
  [...nodes.keys()].forEach(lev);
  const layers = [];
  for (const [id,v] of level.entries()){ (layers[v]|| (layers[v]=[])).push(id); }

  const XSTEP=160, YSTEP=90, PAD=20;
  const width = (layers.length+1)*XSTEP + PAD*2;
  const height = Math.max(...layers.map(a=>a.length))*YSTEP + PAD*2;

  const pos = new Map();
  layers.forEach((ids,x)=>ids.forEach((id,y)=>pos.set(id,{x:PAD+x*XSTEP, y:PAD+y*YSTEP})));

  function gateShape(g){
    const p = pos.get(g.id); const w=60,h=40;
    const cx=p.x, cy=p.y;
    if (g.type==="IN") return `<rect x="${cx}" y="${cy}" width="50" height="26" rx="6"/><text x="${cx+25}" y="${cy+18}" text-anchor="middle">${g.label||g.id}</text>`;
    const label = g.type;
    return `<rect x="${cx}" y="${cy}" width="${w}" height="${h}" rx="10"/><text x="${cx+w/2}" y="${cy+h/2+5}" text-anchor="middle">${label}</text>`;
  }
  function wires(g){
    const p = pos.get(g.id); const gx=p.x, gy=p.y;
    const targets = (g.ins||[]);
    return targets.map(inp=>{
      const pi = pos.get(inp)||{x:gx-60,y:gy}; // const nodes
      const x1 = pi.x + 60, y1 = pi.y + 20;
      const x2 = gx,       y2 = gy + 20;
      const mx = (x1+x2)/2;
      return `<path d="M${x1},${y1} C ${mx},${y1} ${mx},${y2} ${x2},${y2}" fill="none" stroke="currentColor"/>`;
    }).join("");
  }

  const nodesSVG = [...nodes.values()].map(g=>gateShape(g)).join("");
  const wiresSVG = [...net.gates].map(g => wires(g)).join("");


  return `<svg viewBox="0 0 ${width} ${height}" width="100%" style="max-height:520px">
    <g fill="none" stroke="currentColor" stroke-width="2">
      ${wiresSVG}
    </g>
    <g fill="currentColor" stroke="none">
      ${nodesSVG}
      <!-- output label -->
      <text x="${pos.get(net.output).x+80}" y="${pos.get(net.output).y+25}" >F</text>
    </g>
  </svg>`;
}


async function drawCircuit(style){
  const text = exprEl.value.trim();
  const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
  if (!text) { alert("Enter an expression"); return; }
  resEl.textContent = `Generating ${style.toUpperCase()} circuit…`;
  ttCard.style.display="none"; ttEl.innerHTML="";

  const r = await fetch(API + "/api/ba/netlist", {
    method:"POST", headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ expr: text, vars, style })
  });
  const j = await r.json();
  if (!j.ok) { resEl.innerHTML = `<span class="muted">Error: ${j.error}</span>`; return; }
  resEl.innerHTML = renderCircuitSVG(j); // inject your SVG
}

document.getElementById("btnCircuit").addEventListener("click", () => drawCircuit("mixed"));
document.getElementById("btnCircuitNAND").addEventListener("click", () => drawCircuit("nand"));
document.getElementById("btnCircuitNOR").addEventListener("click", () => drawCircuit("nor"));













  
</script>




  
</body>
</html>
