<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none }
    a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:auto; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
    .grid > .card.wide { grid-column: 1 / -1; }

    /* Ensure big SVGs aren’t clamped */
    #result svg { max-height: none !important; width: 100%; height: auto; }

    /* More room when wide */
    aside.card.wide { padding-block: 24px; }
  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses. Implicit AND allowed, e.g., <b>AB + A~C</b>. K-map commands: <b>kmap A,B,C : Σm(1,3,5)</b> or <b>kmap A,B : ΠM(0,2)</b>, or <b>kmap A,B,C : AB + A'C</b>.</p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>
          <button class="btn secondary" id="btnCircuit">Circuit</button>
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>
          <button class="btn secondary" id="btnKmapGroups">K-map Pairings &amp; Solution</button>
          <button class="btn secondary" id="btnClear">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>

<script type="module">
  const API = "https://polycode-ba.onrender.com";
  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");
  const gray = n => n ^ (n >> 1);

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = ""; varsEl.value = "";
    resEl.innerHTML = ""; ttCard.style.display = "none"; ttEl.innerHTML = "";
  });

  /* ---------- KMAP PARSING (Σ / Π / expr) ---------- */
  function parseKmapCommand(s){
    const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
    if (!mHdr) return null;

    const vars = mHdr[1].split(",").map(x=>x.trim());
    let rhs = mHdr[2].trim();

    // Optional don't-cares: ; d(…)
    let dontCares = [];
    const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
    if (mDC) { dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite); rhs = rhs.slice(0, mDC.index).trim(); }

    const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
    const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
    const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

    if (reSigma.test(rhs)) {
      const mm = reSigma.exec(rhs);
      const minterms = parseList(mm[1]);
      return { vars, mode:"ones", minterms, dontCares };
    }
    if (rePi.test(rhs)) {
      const mm = rePi.exec(rhs);
      const maxterms = parseList(mm[1]);
      const n = vars.length, U = Array.from({length:1<<n},(_,i)=>i);
      const bad = new Set([...maxterms, ...dontCares]);
      const minterms = U.filter(i => !bad.has(i)); // for grid display
      return { vars, mode:"zeros", maxterms, minterms, dontCares };
    }
    if (/^[0-9,\s]+$/.test(rhs)) {
      const minterms = parseList(rhs);
      return { vars, mode:"ones", minterms, dontCares };
    }
    return { vars, expr: rhs, dontCares };
  }

  /* ---------- BASIC GRID (compact HTML table) ---------- */
  function renderKmapTable(vars, minterms){
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;

    const grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
    for (let i=0; i<(1<<n); i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const rowLabels = Array.from({length:rows}, (_,r)=>(gray(r)>>>0).toString(2).padStart(rbits,'0'));
    const colLabels = Array.from({length:cols}, (_,c)=>(gray(c)>>>0).toString(2).padStart(cbits,'0'));

    const head =
      `<tr><th>${vars.slice(0,rbits).join("") || "&nbsp;"}</th>` +
      colLabels.map(l=>`<th>${vars.slice(rbits).join("")? vars.slice(rbits).join("")+"="+l : l}</th>`).join("") + `</tr>`;
    const body = grid.map((row,r) =>
      `<tr><th>${vars.slice(0,rbits).join("")? vars.slice(0,rbits).join("")+"="+rowLabels[r] : rowLabels[r]}</th>` +
      row.map(v=>`<td>${v}</td>`).join("") + `</tr>`
    ).join("");

    resEl.innerHTML = `
      <div class="mono">K-map (${n} vars): ${vars.join(", ")}</div>
      <table style="margin-top:8px"><thead>${head}</thead><tbody>${body}</tbody></table>
      <div class="muted" style="margin-top:8px">Tip: groups are powers of 2; wrap edges.</div>
    `;
  }

  /* ---------- BIG SVG KMAP WITH GROUPS (bridges + numbering) ---------- */
  function renderKmapSVG(vars, minterms, groups = [], title = "K-map", opts = {}) {
    const mode   = opts.mode ?? "ones";      // "ones" (SOP) | "zeros" (POS)
    const scale  = opts.scale ?? 2.0;
    const cellW  = Math.round(42 * scale);
    const cellH  = Math.round(30 * scale);
    const pad    = Math.round(24 * scale);
    const font14 = Math.round(14 * scale);
    const font12 = Math.round(12 * scale);

    // dims
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;
    const gray = x => x ^ (x>>1);

    // grid (1 = minterm)
    const grid = Array.from({length:rows},()=>Array(cols).fill(0));
    for (let i=0;i<(1<<n);i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const W = pad*2 + cols*cellW + 100, H = pad*2 + rows*cellH + 40;
    const X0 = pad, Y0 = pad, X1 = pad + cols*cellW, Y1 = pad + rows*cellH;

    // split a toroidal rect into up to 4 screen rects
    function splitSegments(g){
      const r0 = ((g.r % rows) + rows) % rows;
      const c0 = ((g.c % cols) + cols) % cols;
      const rh1 = Math.min(g.hr, rows - r0);
      const cw1 = Math.min(g.wr, cols - c0);

      const segs = [{ r:r0, c:c0, hr:rh1, wr:cw1 }];
      if (g.wr > cw1) segs.push({ r:r0, c:0, hr:rh1, wr:g.wr - cw1 });
      if (g.hr > rh1){
        segs.push({ r:0, c:c0, hr:g.hr - rh1, wr:cw1 });
        if (g.wr > cw1) segs.push({ r:0, c:0, hr:g.hr - rh1, wr:g.wr - cw1 });
      }
      return { segs, r0, c0, wrapH: (c0 + g.wr) > cols, wrapV: (r0 + g.hr) > rows };
    }

    // palette & styles
    const palette = [
      "#FF6B6B","#4DD0E1","#FFD166","#A78BFA",
      "#26A69A","#F48FB1","#64B5F6","#FF8A65",
      "#81C784","#E57373"
    ];
    const dashAttr = (mode === "zeros")
      ? ` stroke-dasharray="${Math.round(6*scale)} ${Math.round(4*scale)}"`
      : "";

    // cells
    const cells = grid.map((row,ri)=>
      row.map((v,ci)=>{
        const x = X0 + ci*cellW, y = Y0 + ri*cellH;
        return `<rect x="${x}" y="${y}" width="${cellW}" height="${cellH}" fill="none" stroke="currentColor" opacity="0.35"/>
                <text x="${x+cellW/2}" y="${y+cellH/2+font14/3}" text-anchor="middle"
                      class="mono" font-size="${font14}" fill="currentColor">${v}</text>`;
      }).join("")
    ).join("");

    // labels
    const colLbl = Array.from({length:cols},(_,c)=> (gray(c)>>>0).toString(2).padStart(cbits,'0'))
      .map((l,i)=>`<text x="${X0 + i*cellW + cellW/2}" y="${Y0-6}" text-anchor="middle"
                    class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");
    const rowLbl = Array.from({length:rows},(_,r)=> (gray(r)>>>0).toString(2).padStart(rbits,'0'))
      .map((l,i)=>`<text x="${X0-6}" y="${Y0 + i*cellH + cellH/2+font12/3}"
                    text-anchor="end" class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");

    // groups: outlines + numbers + wrap bridges
    let rects = "", labels = "", bridges = "";
    groups.forEach((g,gi)=>{
      const color = palette[gi % palette.length];
      const { segs, r0, c0, wrapH, wrapV } = splitSegments(g);

      segs.forEach(s=>{
        const x = X0 + s.c*cellW, y = Y0 + s.r*cellH;
        const w = s.wr*cellW,    h = s.hr*cellH;
        rects += `<rect x="${x+2}" y="${y+2}" width="${w-4}" height="${h-4}"
                         rx="${Math.round(8*scale)}" fill="none"
                         stroke="${color}" stroke-width="2"${dashAttr}
                         vector-effect="non-scaling-stroke"/>`;
        labels += `<text x="${x + w/2}" y="${y + h/2 + font12/3}" text-anchor="middle"
                         class="mono" font-size="${font12}" fill="${color}">${gi+1}</text>`;
      });

      if (wrapH) {
        const yMid = Y0 + ((r0 + g.hr/2) % rows) * cellH;
        const L = Math.round(10 * scale);
        bridges += `<path d="M${X0-L},${yMid} H${X0}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
        bridges += `<path d="M${X1},${yMid} H${X1+L}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
      }
      if (wrapV) {
        const xMid = X0 + ((c0 + g.wr/2) % cols) * cellW;
        const L = Math.round(10 * scale);
        bridges += `<path d="M${xMid},${Y0-L} V${Y0}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
        bridges += `<path d="M${xMid},${Y1} V${Y1+L}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
      }
    });

    const subtitle = (mode === "zeros")
      ? `<div class="muted mono">Mode: POS — groups on 0-cells (dashed). Same color/number = one wrap-group.</div>`
      : `<div class="muted mono">Mode: SOP — groups on 1-cells. Same color/number = one wrap-group.</div>`;

    return `<div class="mono" style="margin:.5rem 0 .25rem">${title}</div>
            ${subtitle}
            <svg viewBox="0 0 ${W} ${H}" width="100%">
              <g fill="none" stroke="currentColor">${cells}</g>
              <g fill="currentColor">${colLbl}${rowLbl}</g>
              <g fill="none">${rects}</g>
              <g>${labels}</g>
              <g fill="none">${bridges}</g>
            </svg>`;
  }

  /* ---------- K-map de-dup helpers (client-side) ---------- */
  function dimsFromVars(vars){
    const n = vars.length, rbits = Math.floor(n/2);
    return { rows: 1<<rbits, cols: 1<<(n-rbits) };
  }
  function rectCellKey(g, vars){
    const { rows, cols } = dimsFromVars(vars);
    const cells = [];
    for (let i=0;i<g.hr;i++){
      for (let j=0;j<g.wr;j++){
        cells.push(`${(g.r+i)%rows},${(g.c+j)%cols}`);
      }
    }
    cells.sort();
    return cells.join("|");
  }
  function dedupeRectsClient(rects, vars){
    const seen = new Set(), out = [];
    for (const r of rects){
      const k = rectCellKey(r, vars);
      if (seen.has(k)) continue;
      seen.add(k); out.push(r);
    }
    return out;
  }




// Manhattan, color-coded logic renderer with barycenter ordering + wire splitting
// Manhattan, color-coded logic renderer with barycenter ordering + clean HVH wiring

// Manhattan, color-coded logic renderer with obstacle-aware HVH wiring
// Manhattan, clean wiring, circular inputs, classic OR shape
function renderCircuitSVG(net, opts = {}) {
  const caption = opts.caption ?? "";
  let   scale   = opts.scale ?? "fit";      // 'fit' or number
  const fitW    = opts.fitWidth ?? 1000;
  const zoom    = opts.zoom ?? 1.6;

  // --- Base geometry (pre-scale) ---
  const GW0=72, GH0=46, PIN0=10, XSTEP0=180, YSTEP0=100, PAD0=28;

  // --- Gate glyph helpers (parametric in scale) ---
  const bubble = (x, y, s) =>
    `<circle cx="${x}" cy="${y}" r="${Math.round(6*s)}"
             stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;

  const gateAND = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const r = GH/2, xr = x + GW - r;
    return `<path d="M${x},${y} H${xr} A${r},${r} 0 0 1 ${xr},${y+GH} H${x} Z"
             stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
  };

  // Classic OR with *outer* hull + *inner back arc*
  const gateOR = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const r  = GH/2, b=y+GH;
    const xIn  = x + Math.round(14*s);
    const xOut = x + GW - Math.round(10*s);
    const xm   = x + GW - Math.round(22*s);
    const outer =
      `<path d="M${xIn},${y}
               C ${xm-22},${y} ${xm},${y+r} ${xOut},${y+r}
               C ${xm},${y+r} ${xm-22},${b} ${xIn},${b}
               C ${x+6},${b-10} ${x+6},${y+10} ${xIn},${y}"
         stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
    const back =  // inner concave spine
      `<path d="M${xIn-Math.round(10*s)},${y}
               C ${xm-32},${y} ${xm-10},${y+r} ${xIn-Math.round(10*s)},${b}"
         stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
    return outer + back;
  };

  const gateXOR = (x, y, s) => {
    // XOR = OR shape + an extra back line a bit farther left
    const or = gateOR(x, y, s);
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const r  = GH/2, b=y+GH;
    const xIn2 = x + Math.round(2*s);
    const xm   = x + GW - Math.round(24*s);
    const extra =
      `<path d="M${xIn2},${y} C ${xm-32},${y} ${xm-10},${y+r} ${xIn2},${b}"
         stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
    return or + extra;
  };

  const gateNOT = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const tri = `<path d="M${x},${y} L${x},${y+GH} L${x+GW-12},${y+GH/2} Z"
                 stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
    return tri + bubble(x + GW - 4*s, y + GH/2, s);
  };

  // --- Build graph & adjacency ---
  const nodes = new Map(), succ = new Map(), pred = new Map();
  const addNode = n => { nodes.set(n.id, n); succ.has(n.id)||succ.set(n.id,[]); pred.has(n.id)||pred.set(n.id,[]); };

  net.gates.forEach(g => addNode({...g}));
  net.inputs.forEach(i => addNode({ id:i.id, type:"IN", ins:[], label:i.label }));
  addNode({ id: net.output, type: nodes.get(net.output)?.type || "OUT", ins: nodes.get(net.output)?.ins || [] });

  nodes.forEach(n => (n.ins||[]).forEach(p => {
    if(!nodes.has(p)) addNode({id:p,type:"WIRE",ins:[]});
    succ.get(p).push(n.id); pred.get(n.id).push(p);
  }));

  // --- Layering (longest-path) ---
  const level = new Map();
  const lev = id => level.has(id) ? level.get(id)
    : level.set(id, (["IN","VCC","GND"].includes(nodes.get(id)?.type)) ? 0
      : Math.max(0,...(pred.get(id)||[]).map(lev))+1).get(id);
  nodes.forEach((_,id)=>lev(id));

  // Split long edges into per-layer WIRE nodes
  let wid=0; const widNew=()=>`_W${wid++}`;
  pred.forEach((parents, child)=>{
    const lc=level.get(child);
    parents.slice().forEach(p=>{
      const lp=level.get(p);
      if (lc-lp<=1) return;
      succ.set(p,(succ.get(p)||[]).filter(x=>x!==child));
      pred.set(child,(pred.get(child)||[]).filter(x=>x!==p));
      let prev=p;
      for (let L=lp+1; L<lc; L++){
        const w=widNew(); addNode({id:w,type:"WIRE",ins:[prev]}); level.set(w,L);
        succ.get(prev).push(w); pred.get(w).push(prev); prev=w;
      }
      succ.get(prev).push(child); pred.get(child).push(prev);
    });
  });

  // Layers array
  let layers=[]; level.forEach((v,id)=> (layers[v]||(layers[v]=[])).push(id));

  // --- Compute scale AFTER we know how many layers we'll draw ---
  if (scale === "fit") {
    const baseW = (layers.length+1)*XSTEP0 + 2*PAD0;
    scale = Math.max(1.15, (fitW*zoom) / baseW);
  }
  const s = +scale;
  const GW=Math.round(GW0*s), GH=Math.round(GH0*s), PIN=Math.round(PIN0*s);
  const XSTEP=Math.round(XSTEP0*s), YSTEP=Math.round(YSTEP0*s), PAD=Math.round(PAD0*s);
  const FAN_STUB = Math.round(14*s);      // short H escape from a source
  const FAN_GAP  = Math.round(10*s);      // vertical spacing between fanout lanes

  // Dimensions by type (so wires terminate at the *edge* of the gate)
  const typeWidth  = t => (t === "IN" ? Math.round(24*s) : GW);
  const typeHeight = t => (t === "IN" ? Math.round(20*s) : GH);

  // Absolute top-left for each node
  const abs = new Map();
  layers.forEach((ids,lx)=>{
    ids.forEach((id,ly)=>{
      abs.set(id,{x:PAD+lx*XSTEP, y:PAD+ly*YSTEP});
    });
  });

  const width  = (layers.length+1)*XSTEP + 2*PAD;
  const height = Math.max(1,...layers.map(a=>a.length))*YSTEP + 2*PAD + (caption?Math.round(28*s):0);

  const pinY = (y,n,k)=> y + GH*((k+1)/(Math.max(1,n)+1));

  // --- Gate drawing ---
  function drawGate(n){
    if (n.type==="WIRE") return "";
    const p=abs.get(n.id);
    if (n.type==="IN"){
      // circular input + white, larger label to the left
      const r = Math.round(9*s);
      const cx = p.x + r, cy = p.y + r;
      const jack = `<line x1="${cx+r}" y1="${cy}" x2="${cx+r+PIN}" y2="${cy}"/>`;
      return `<g class="gate IN" color="currentColor">
        <circle cx="${cx}" cy="${cy}" r="${r}" />
        ${jack}
        <text x="${p.x - Math.round(8*s)}" y="${cy + Math.round(5*s)}"
              text-anchor="end" class="mono inlabel">${n.label||n.id}</text>
      </g>`;
    }
    if (n.type==="OUT") return ""; // drawn as label only

    const nIns=(n.ins||[]).length||1;
    const pins = Array.from({length:nIns},(_,k)=>{
      const py = pinY(p.y, nIns, k);
      return `<line x1="${p.x-PIN}" y1="${py}" x2="${p.x}" y2="${py}"/>`;
    }).join("");

    const wrap = (cls,body)=>`<g class="gate ${cls}" color="currentColor">${pins}${body}</g>`;
    if (n.type==="NOT")  return wrap("NOT",  gateNOT(p.x,p.y,s));
    if (n.type==="AND")  return wrap("AND",  gateAND(p.x,p.y,s));
    if (n.type==="OR")   return wrap("OR",   gateOR(p.x,p.y,s));
    if (n.type==="XOR")  return wrap("XOR",  gateXOR(p.x,p.y,s));
    if (n.type==="NAND") return wrap("NAND", gateAND(p.x,p.y,s) + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
    if (n.type==="NOR")  return wrap("NOR",  gateOR(p.x,p.y,s)  + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
    if (n.type==="XNOR") return wrap("XNOR", gateXOR(p.x,p.y,s) + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
    return wrap("OTHER", `<rect x="${p.x}" y="${p.y}" width="${GW}" height="${GH}" rx="${Math.round(10*s)}"/>
                          <text x="${p.x+GW/2}" y="${p.y+GH/2+5}" text-anchor="middle" class="mono">${n.type}</text>`);
  }

  // --- Wire routing: orthogonal H–V–H with lane separation ---
  const outX = id => {
    const t = nodes.get(id)?.type || "WIRE";
    const p = abs.get(id);
    return p.x + typeWidth(t);
  };

  function wiresTo(tid){
    const t   = nodes.get(tid);
    const dst = abs.get(tid);
    const xL  = dst.x, yT = dst.y;
    const ins = (t.ins || []);

    return ins.map((sid, k) => {
      const sp = abs.get(sid);
      const x1 = outX(sid);                                   // right edge of source
      const y1 = sp.y + (nodes.get(sid)?.type==="IN" ? Math.round(9*s) : GH/2);  // center or input circle center

      // fanout lane for this source edge
      const outList    = succ.get(sid) || [];
      const outIdx     = Math.max(0, outList.indexOf(tid));
      const outCount   = Math.max(1, outList.length);
      const laneOffset = (outIdx - (outCount - 1) / 2) * FAN_GAP;

      const x2 = xL;                                   // stop at *edge* of gate
      const y2 = pinY(yT, ins.length || 1, k);

      // keep inputs separated near destination
      const track  = Math.round(22 * s);
      const bendX  = x2 - Math.round(GW / 4) - (k + 1) * track;

      // Route: short escape → lane → across → down → into pin (stop 1px before face)
      return `M${x1},${y1} h${FAN_STUB} v${laneOffset} H${bendX} V${y2} H${x2-1}`;
    }).join(" ");
  }

  const wiresSVG = Array.from(nodes.values())
    .filter(n=>(n.ins||[]).length)
    .map(n=>`<path d="${wiresTo(n.id)}" class="wire"/>`)
    .join("");

  const gatesSVG = Array.from(nodes.values()).map(drawGate).join("");
  const outPos = abs.get(net.output) || { x: width-80, y: height/2 };

  // --- Embedded styles (inputs white/bigger; clean wires; classic OR color) ---
  const style = `
  <style>
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: ${Math.max(12, Math.round(12*s))}px; }
    .wire { stroke: #cfd7e1; stroke-width: ${Math.max(2.8, 2.8*s)}; stroke-linecap: round; stroke-linejoin: round; fill: none; }
    .gate line, .gate path, .gate rect, .gate circle { stroke-width: ${Math.max(2.8, 2.8*s)}; stroke-linecap: round; stroke-linejoin: round; fill: none; }
    .gate.IN circle { stroke:#B0BEC5; }
    .gate.IN .inlabel { fill:#ffffff; font-weight:700; font-size:${Math.max(14, Math.round(14*s))}px; }
    .gate.AND  path, .gate.AND rect  { stroke:#3DDC97; }
    .gate.OR   path                 { stroke:#FFB86B; }
    .gate.XOR  path                 { stroke:#FF79C6; }
    .gate.NOT  path                 { stroke:#8BE9FD; }
    .gate.NAND path, .gate.NAND rect{ stroke:#00C853; }
    .gate.NOR  path                 { stroke:#FF7043; }
    .gate.XNOR path                 { stroke:#8E44AD; }
    .gate.OTHER rect                { stroke:#9aa4b2; }
  </style>`;

  const captionSVG = caption
    ? `<text x="${PAD}" y="${height - Math.round(10*s)}" class="mono" fill="currentColor">F = ${caption}</text>`
    : "";

  return `<svg viewBox="0 0 ${width} ${height}" width="100%" preserveAspectRatio="xMinYMin meet">
    ${style}
    <g class="wires">${wiresSVG}</g>
    <g class="gates">${gatesSVG}</g>
    <g class="labels" fill="currentColor">
      ${captionSVG}
      <text x="${outPos.x + Math.round(90*s)}" y="${outPos.y + Math.round(24*s)}" class="mono">F</text>
    </g>
  </svg>`;
}











  
  const resultCard = document.querySelector("aside.card");

  async function drawCircuit(style){
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) { alert("Enter an expression"); return; }

    resEl.textContent = `Generating ${style.toUpperCase()} circuit…`;
    ttCard.style.display="none"; ttEl.innerHTML="";

    resultCard?.classList.add("wide");

    const r = await fetch(API + "/api/ba/netlist", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ expr: text, vars, style })
    });
    const j = await r.json();
    if (!j.ok) { resEl.innerHTML = `<span class="muted">Error: ${j.error}</span>`; return; }

    requestAnimationFrame(() => {
      const fitWidth = resultCard.getBoundingClientRect().width - 32;
      resEl.innerHTML = renderCircuitSVG(j, {
        caption: exprEl.value.trim(),
        scale: 'fit',
        fitWidth,
        zoom: 2.2
      });
    });
  }

  $("#btnCircuit").addEventListener("click", () => drawCircuit("mixed"));
  $("#btnCircuitNAND").addEventListener("click", () => drawCircuit("nand"));
  $("#btnCircuitNOR").addEventListener("click", () => drawCircuit("nor"));

  /* ---------- SIMPLIFY button ---------- */
  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    // K-map command?
    const km = parseKmapCommand(text);
    if (km) {
      ttCard.style.display = "none"; ttEl.innerHTML = "";
      resEl.textContent = "Building K-map…";

      try {
        // If expression was provided after `kmap ...`, compute minterms for grid display
        let displayMins = km.minterms;
        if (km.expr) {
          const r1 = await fetch(API + "/api/ba/simplify", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
          });
          const j1 = await r1.json();
          if (!j1.ok) throw new Error(j1.error || "simplify error");
          displayMins = j1.minterms;
        }

        // payload for kmap
        const body =
          km.mode === "zeros"
            ? { vars: km.vars, mode: "zeros", maxterms: km.maxterms, full: true }
            : { vars: km.vars, mode: "ones",  minterms: displayMins, full: true };

        const r = await fetch(API + "/api/ba/kmap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const j = await r.json();
        if (!j.ok) throw new Error(j.error || "kmap error");

        // DE-DUPE solution groups before drawing
        const solGroups = dedupeRectsClient(j.solutionGroups || [], km.vars);

        resEl.innerHTML = renderKmapSVG(
          km.vars,
          displayMins,
          solGroups,
          j.mode === "zeros"
            ? `Solution (POS): ${j.simplified}`
            : `Solution (SOP): ${j.simplified}`,
          { mode: j.mode, scale: 2.2 }
        );
      } catch (e) {
        resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      }
      return;
    }

    // Otherwise, normal simplify flow
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else {
        ttCard.style.display="none"; ttEl.innerHTML="";
      }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });

  /* ---------- KMAP Pairings & Solution (big SVG) ---------- */
  async function showKmapGroups() {
    const text = exprEl.value.trim();
    if (!text) { alert("Type a kmap command or an expression."); return; }

    let vars, mode = "ones", minterms, maxterms;
    const km = parseKmapCommand(text);

    if (km) {
      vars = km.vars;
      mode = km.mode;                // "ones" | "zeros"
      if (km.expr) {
        const r1 = await fetch(API + "/api/ba/simplify", {
          method:"POST", headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
        });
        const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
        minterms = j1.minterms;
      } else {
        minterms = km.minterms;
        maxterms = km.maxterms;
      }
    } else {
      // plain expression: compute minterms; SOP by default
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars: varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
      vars = j1.vars; minterms = j1.minterms;
    }

    const body = (mode === "zeros")
      ? { vars, mode:"zeros", maxterms: maxterms ?? [], full: true }
      : { vars, mode:"ones",  minterms: minterms ?? [], full: true };

    const r2 = await fetch(API + "/api/ba/kmap", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    const j2 = await r2.json();
    if (!j2.ok) { resEl.innerHTML = `<span class="muted">Error: ${j2.error}</span>`; return; }

    // DE-DUPE both pairings and solution groups
    const pairsRaw = (j2.allGroups || []).filter(g => g.hr*g.wr === 2);
    const pairs = dedupeRectsClient(pairsRaw, vars);
    const solution = dedupeRectsClient(j2.solutionGroups || [], vars);

    resEl.innerHTML =
      renderKmapSVG(vars, minterms ?? [], pairs, "All pairings (size 2)", { mode, scale: 2.0 }) +
      renderKmapSVG(vars, minterms ?? [], solution,
        mode === "zeros" ? `Solution (POS): ${j2.simplified}` : `Solution (SOP): ${j2.simplified}`,
        { mode, scale: 2.2 });
  }

  $("#btnKmapGroups").addEventListener("click", () => {
    ttCard.style.display="none"; ttEl.innerHTML="";
    resEl.textContent = "Analyzing K-map…";
    showKmapGroups().catch(e => resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`);
  });
</script>
</body>
</html>
