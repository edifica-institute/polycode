<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none }
    a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:100%; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses. Implicit AND allowed, e.g., <b>AB + A~C</b>.</p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>
          <button class="btn secondary" id="btnCircuit">Circuit</button>
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>
<button class="btn secondary" id="btnKmapGroups">K-map Pairings & Solution</button>

          <button class="btn secondary" id="btnClear">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>



<script type="module">
  const API = "https://polycode-ba.onrender.com";

  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = "";
    varsEl.value = "";
    resEl.innerHTML = "";
    ttCard.style.display = "none";
    ttEl.innerHTML = "";
  });

  const gray = n => n ^ (n >> 1);

function parseKmapCommand(s){
  // kmap <vars> [:|=] < list | Σm(...) | ΠM(...) | boolean expr > [ ; d(...) ]
  const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
  if (!mHdr) return null;

  const vars = mHdr[1].split(",").map(x=>x.trim());
  let rhs = mHdr[2].trim();

  // Optional don't-cares at end: ; d(...)
  let dontCares = [];
  const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
  if (mDC) {
    dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite);
    rhs = rhs.slice(0, mDC.index).trim();
  }

  const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
  const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
  const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

  // Σm(...)
  if (reSigma.test(rhs)) {
    const mm = reSigma.exec(rhs);
    return { vars, minterms: parseList(mm[1]), dontCares };
  }
  // ΠM(...) => convert to minterms (exclude don't-cares)
  if (rePi.test(rhs)) {
    const mm = rePi.exec(rhs);
    const maxterms = parseList(mm[1]);
    const n = vars.length;
    const universe = Array.from({length: 1<<n}, (_,i)=>i);
    const bad = new Set([...maxterms, ...dontCares]);
    return { vars, minterms: universe.filter(i => !bad.has(i)), dontCares };
  }
  // Plain list 1,2,3
  if (/^[0-9,\s]+$/.test(rhs)) {
    return { vars, minterms: parseList(rhs), dontCares };
  }
  // Otherwise treat as a boolean expression (e.g., AB + A'C)
  return { vars, expr: rhs, dontCares };
}



  function renderKmap(vars, minterms){
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1 << rbits, cols = 1 << cbits;

    const grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
    for (let i=0; i < (1<<n); i++){
      const r = gray(i >> cbits) & (rows - 1);
      const c = gray(i & ((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const rowLabels = Array.from({length:rows}, (_,r)=> (gray(r) >>> 0).toString(2).padStart(rbits,'0'));
    const colLabels = Array.from({length:cols}, (_,c)=> (gray(c) >>> 0).toString(2).padStart(cbits,'0'));

    const head =
      `<tr><th>${vars.slice(0,rbits).join("") || "&nbsp;"}</th>` +
      colLabels.map(l=>`<th>${vars.slice(rbits).join("")? vars.slice(rbits).join("")+"="+l : l}</th>`).join("") +
      `</tr>`;
    const body = grid.map((row,r) =>
      `<tr><th>${vars.slice(0,rbits).join("")? vars.slice(0,rbits).join("")+"="+rowLabels[r] : rowLabels[r]}</th>` +
      row.map(v=>`<td>${v}</td>`).join("") + `</tr>`
    ).join("");

    resEl.innerHTML = `
      <div class="mono">K-map (${n} vars): ${vars.join(", ")}</div>
      <div class="muted mono">Minterms: [${minterms.join(", ")}]</div>
      <table style="width:auto;border-collapse:collapse;margin-top:8px;font-size:14px">
        <thead>${head}</thead>
        <tbody>${body}</tbody>
      </table>
      <div class="muted" style="margin-top:8px">Tip: groups are powers of 2; wrap edges when grouping.</div>
    `;
  }

  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    // --- KMAP COMMAND? ---
    const km = parseKmapCommand(text);
if (km) {
  ttCard.style.display = "none"; ttEl.innerHTML = "";
  resEl.textContent = "Building K-map…";
  try {
    // NEW: if user gave an expression, get its minterms first
    let minterms = km.minterms;
    if (km.expr) {
      const r1 = await fetch(API + "/api/ba/simplify", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
      });
      const j1 = await r1.json();
      if (!j1.ok) throw new Error(j1.error || "simplify error");
      minterms = j1.minterms;
    }

    // Optional: ask backend for grouping hints (or skip and just render)
    /* const r2 = await fetch(API + "/api/ba/kmap", {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({ vars: km.vars, minterms })
       });
       const j2 = await r2.json();
       if (!j2.ok) throw new Error(j2.error || "kmap error");
    */

    renderKmap(km.vars, minterms);
  } catch (e) {
    resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
  }
  return;
}
    // --- OTHERWISE: normal simplify flow ---
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else {
        ttCard.style.display="none"; ttEl.innerHTML="";
      }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });



// dumb layout: layer by distance from inputs
function renderCircuitSVG(net){
  const inSet = new Set(net.inputs.map(i=>i.id));
  const nodes = new Map();
  for (const g of net.gates) nodes.set(g.id, {...g});
  for (const i of net.inputs) nodes.set(i.id, { id:i.id, type:"IN", ins:[], label:i.label });
  nodes.set(net.output, nodes.get(net.output) || { id:net.output, type:"OUT", ins:[] });

  // Longest-path level (layer) layout
  const level = new Map();
  function lev(id){
    if (level.has(id)) return level.get(id);
    const n = nodes.get(id) || {ins:[]};
    const v = (n.type==="IN" || id==="VCC_1" || id==="GND_0") ? 0 : Math.max(0, ...(n.ins||[]).map(lev)) + 1;
    level.set(id, v); return v;
  }
  [...nodes.keys()].forEach(lev);
  const layers = [];
  for (const [id,v] of level.entries()){ (layers[v] || (layers[v]=[])).push(id); }

  const XSTEP=160, YSTEP=90, PAD=24;
  const width = (layers.length+1)*XSTEP + PAD*2;
  const height = Math.max(1,...layers.map(a=>a.length))*YSTEP + PAD*2;

  const pos = new Map();
  layers.forEach((ids,x)=>ids.forEach((id,y)=>pos.set(id,{x:PAD+x*XSTEP, y:PAD+y*YSTEP})));

  // ---- gate icons (distinct silhouettes) ----
  function bubble(x,y,r=5){ return `<circle cx="${x}" cy="${y}" r="${r}" stroke="currentColor" fill="var(--panel,transparent)"/>`; }
  function gateAND(x,y,w=64,h=40){
    const r=h/2;
    const xr = x + w - r, xb = x + w;
    return `<path d="M${x},${y} H${xr} A${r},${r} 0 0 1 ${xr},${y+h} H${x} Z" stroke="currentColor" fill="none"/>`;
  }
  function gateOR(x,y,w=64,h=40){
    const x1=x+12, x2=x+w-8, xm=x+w-20, b=y+h;
    // simple cubic-bezier approximation of an OR gate
    return `<path d="M${x1},${y} C ${xm-18},${y} ${xm},${y+h/2} ${x2},${y+h/2}
                     C ${xm},${y+h/2} ${xm-18},${b} ${x1},${b}
                     C ${x+4},${b-6} ${x+4},${y+6} ${x1},${y}"
             stroke="currentColor" fill="none"/>`;
  }
  function gateXOR(x,y,w=64,h=40){
    // OR plus a parallel offset curve at the input side
    const or = gateOR(x,y,w,h);
    const x1=x+6, xm=x+w-20, b=y+h;
    const extra = `<path d="M${x1},${y} C ${xm-18},${y} ${xm},${y+h/2} ${x1},${b}"
                   stroke="currentColor" fill="none"/>`;
    return or + extra;
  }
  function gateNOT(x,y,w=56,h=36){
    return `<path d="M${x},${y} L${x},${y+h} L${x+w-10},${y+h/2} Z" stroke="currentColor" fill="none"/>` +
           bubble(x+w-2, y+h/2, 5);
  }

  function gateShape(g){
    const {x, y} = pos.get(g.id);
    const w=64, h=40;
    const outX = x + w, outY = y + h/2;

    if (g.type === "IN") {
      return `<rect x="${x}" y="${y}" width="54" height="26" rx="6" stroke="currentColor" fill="none"/>` +
             `<text x="${x+27}" y="${y+18}" text-anchor="middle" fill="currentColor" class="mono">${g.label||g.id}</text>`;
    }
    if (g.type === "NOT") { // triangle + bubble
      return gateNOT(x,y);
    }
    if (g.type === "AND") {
      return gateAND(x,y,w,h);
    }
    if (g.type === "OR") {
      return gateOR(x,y,w,h);
    }
    if (g.type === "XOR") {
      return gateXOR(x,y,w,h);
    }
    if (g.type === "NAND") {
      return gateAND(x,y,w,h) + bubble(outX+8, outY);
    }
    if (g.type === "NOR") {
      return gateOR(x,y,w,h) + bubble(outX+8, outY);
    }
    if (g.type === "XNOR") {
      return gateXOR(x,y,w,h) + bubble(outX+8, outY);
    }
    // Fallback: labeled box
    return `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="10" stroke="currentColor" fill="none"/>` +
           `<text x="${x+w/2}" y="${y+h/2+5}" text-anchor="middle" fill="currentColor" class="mono">${g.type}</text>`;
  }

  // wires between each gate's inputs and the gate body
  function wires(g){
    const p = pos.get(g.id); const gx=p.x, gy=p.y;
    const inputs = (g.ins||[]);
    return inputs.map(inp=>{
      const pi = pos.get(inp) || {x:gx-60,y:gy};
      const x1 = pi.x + 64, y1 = pi.y + 20;
      const x2 = gx,        y2 = gy + 20;
      const mx = (x1+x2)/2;
      return `<path d="M${x1},${y1} C ${mx},${y1} ${mx},${y2} ${x2},${y2}" fill="none" stroke="currentColor"/>`;
    }).join("");
  }

  const wiresSVG = net.gates.map(g=>wires(g)).join("");
  const gatesSVG  = [...nodes.values()].map(g=>gateShape(g)).join("");
  const outPos = pos.get(net.output) || {x: width-60, y: height/2};

  return `<svg viewBox="0 0 ${width} ${height}" width="100%" style="max-height:520px">
    <g class="wires" fill="none" stroke="currentColor" stroke-width="2">
      ${wiresSVG}
    </g>
    <g class="gates" stroke="currentColor" stroke-width="2">
      ${gatesSVG}
    </g>
    <g class="labels" fill="currentColor" stroke="none">
      <text x="${outPos.x+84}" y="${outPos.y+25}" class="mono">F</text>
    </g>
  </svg>`;
}


async function drawCircuit(style){
  const text = exprEl.value.trim();
  const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
  if (!text) { alert("Enter an expression"); return; }
  resEl.textContent = `Generating ${style.toUpperCase()} circuit…`;
  ttCard.style.display="none"; ttEl.innerHTML="";

  const r = await fetch(API + "/api/ba/netlist", {
    method:"POST", headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ expr: text, vars, style })
  });
  const j = await r.json();
  if (!j.ok) { resEl.innerHTML = `<span class="muted">Error: ${j.error}</span>`; return; }
  resEl.innerHTML = renderCircuitSVG(j); // inject your SVG
}

document.getElementById("btnCircuit").addEventListener("click", () => drawCircuit("mixed"));
document.getElementById("btnCircuitNAND").addEventListener("click", () => drawCircuit("nand"));
document.getElementById("btnCircuitNOR").addEventListener("click", () => drawCircuit("nor"));






  
function renderKmapSVG(vars, minterms, groups=[], title="K-map"){
  const n = vars.length;
  const rbits = Math.floor(n/2), cbits = n - rbits;
  const rows = 1<<rbits, cols = 1<<cbits;
  const cellW=42, cellH=30, pad=24;
  const W = pad*2 + cols*cellW + 80, H = pad*2 + rows*cellH + 40;

  const gray = x => x ^ (x>>1);
  const gridVals = Array.from({length:rows},()=>Array(cols).fill(0));
  for (let i=0;i<(1<<n);i++){
    const r = gray(i>>cbits)&(rows-1);
    const c = gray(i&((1<<cbits)-1));
    gridVals[r][c] = minterms.includes(i) ? 1 : 0;
  }

  const rects = groups.map(g=>{
    const x = pad + g.c*cellW;
    const y = pad + g.r*cellH;
    const w = g.wr*cellW;
    const h = g.hr*cellH;
    return `<rect x="${x+2}" y="${y+2}" width="${w-4}" height="${h-4}" rx="8" fill="none" stroke="currentColor" stroke-width="2" opacity="0.9"/>`;
  }).join("");

  const cells = gridVals.map((row,ri)=>
    row.map((v,ci)=>{
      const x = pad + ci*cellW, y = pad + ri*cellH;
      return `<rect x="${x}" y="${y}" width="${cellW}" height="${cellH}" fill="none" stroke="currentColor" opacity="0.35"/>
              <text x="${x+cellW/2}" y="${y+cellH/2+5}" text-anchor="middle" class="mono" font-size="14">${v}</text>`;
    }).join("")
  ).join("");

  const colLbl = Array.from({length:cols},(_,c)=> (gray(c)>>>0).toString(2).padStart(cbits,'0'))
    .map((l,i)=>`<text x="${pad + i*cellW + cellW/2}" y="${pad-6}" text-anchor="middle" class="mono" font-size="12">${l||""}</text>`).join("");
  const rowLbl = Array.from({length:rows},(_,r)=> (gray(r)>>>0).toString(2).padStart(rbits,'0'))
    .map((l,i)=>`<text x="${pad-6}" y="${pad + i*cellH + cellH/2+4}" text-anchor="end" class="mono" font-size="12">${l||""}</text>`).join("");

  return `<div class="mono" style="margin:.5rem 0 .25rem">${title}</div>
  <svg viewBox="0 0 ${W} ${H}" width="100%" style="max-height:360px">
    <g fill="none" stroke="currentColor">${cells}${rects}</g>
    <g fill="currentColor">${colLbl}${rowLbl}</g>
  </svg>`;
}

async function showKmapGroups() {
  const text = exprEl.value.trim();
  if (!text) { alert("Type a kmap command or an expression."); return; }

  // Reuse your parser: accept either "kmap ..." or an expression
  let km = parseKmapCommand(text);
  let vars, minterms;
  if (km) {
    vars = km.vars;
    if (km.expr) {
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
      minterms = j1.minterms;
    } else {
      minterms = km.minterms;
    }
  } else {
    // Normal expr in box → compute mins from simplify; vars from input box if any
    vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    const r1 = await fetch(API + "/api/ba/simplify", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ expr: text, vars, includeTable: false })
    });
    const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
    vars = j1.vars; minterms = j1.minterms;
  }

  // Ask backend for ALL groups + solution groups
  const r2 = await fetch(API + "/api/ba/kmap", {
    method:"POST", headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ vars, minterms, full: true })
  });
  const j2 = await r2.json(); if (!j2.ok) { resEl.innerHTML = `<span class="muted">Error: ${j2.error}</span>`; return; }

  // Split: pairs only; solution groups (thicker stroke)
  const pairs = j2.allGroups.filter(g => g.hr*g.wr === 2);
  const solution = j2.solutionGroups;

  resEl.innerHTML =
    renderKmapSVG(vars, minterms, pairs, "All pairings (size 2)") +
    renderKmapSVG(vars, minterms, solution, `Solution groups → ${j2.simplified}`);
}

document.getElementById("btnKmapGroups")?.addEventListener("click", () => {
  ttCard.style.display="none"; ttEl.innerHTML="";
  resEl.textContent = "Analyzing K-map…";
  showKmapGroups().catch(e => resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`);
});









  
</script>




  
</body>
</html>
