<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none }
    a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:auto; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
    .grid > .card.wide { grid-column: 1 / -1; }

    /* Ensure big SVGs aren’t clamped */
    #result svg { max-height: none !important; width: 100%; height: auto; }

    /* More room when wide */
    aside.card.wide { padding-block: 24px; }
  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses. Implicit AND allowed, e.g., <b>AB + A~C</b>. K-map commands: <b>kmap A,B,C : Σm(1,3,5)</b> or <b>kmap A,B : ΠM(0,2)</b>, or <b>kmap A,B,C : AB + A'C</b>.</p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>

          <!-- NEW -->
          <button class="btn" id="btnSimplifyAndDraw">Simplify &amp; Draw</button>
          <button class="btn secondary" id="btnSimplyDraw">Simply Draw</button>

          <!-- Existing -->
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>
          <button class="btn secondary" id="btnKmapGroups">K-map Pairings &amp; Solution</button>
          <button class="btn secondary" id="btnClear">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>

<!-- Lightweight SVG modal (preview + download) -->
<script>
  function showSvgModal(svgStr, { title = "Circuit" } = {}) {
    const css = `
      .cm-modal{position:fixed;inset:0;z-index:99999;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
      .cm-back{position:absolute;inset:0;background:rgba(0,0,0,.55)}
      .cm-dlg{position:relative;margin:5vh auto;width:min(980px,96vw);max-height:90vh;display:flex;flex-direction:column;
              background:#141922;color:#e9edf3;border-radius:14px;box-shadow:0 24px 60px rgba(0,0,0,.35);overflow:hidden}
      .cm-head,.cm-foot{padding:10px 14px}
      .cm-head{display:flex;align-items:center;gap:12px;border-bottom:1px solid var(--border, #2b2f34)}
      .cm-title{font-size:16px;font-weight:600;flex:1}
      .cm-body{padding:12px 14px;overflow:auto;background:#0b0f13}
      .cm-foot{display:flex;justify-content:flex-end;gap:8px;border-top:1px solid var(--border, #2b2f34);background:#141922}
      .cm-btn{appearance:none;border:1px solid var(--border, #2b2f34);background:#1e2024;color:#e9edf3;border-radius:10px;padding:8px 12px;cursor:pointer}
      .cm-btn:hover{filter:brightness(1.08)}
      .cm-svg{display:flex;justify-content:center}
      .cm-svg svg{max-width:100%;height:auto}
    `;
    if (!document.getElementById('cm-style')) {
      const s = document.createElement('style');
      s.id = 'cm-style'; s.textContent = css; document.head.appendChild(s);
    }
    const svg = String(svgStr || '').trim();
    const wrap = document.createElement('div');
    wrap.className = 'cm-modal';
    wrap.innerHTML = `
      <div class="cm-back"></div>
      <div class="cm-dlg" role="dialog" aria-modal="true">
        <div class="cm-head">
          <div class="cm-title">${title}</div>
          <button class="cm-btn js-close">Close</button>
        </div>
        <div class="cm-body"><div class="cm-svg">${svg}</div></div>
        <div class="cm-foot">
          <button class="cm-btn js-dl-svg">Download SVG</button>
          <button class="cm-btn js-dl-png">Download PNG</button>
          <button class="cm-btn js-close">Close</button>
        </div>
      </div>`;
    document.body.appendChild(wrap);
    function close(){ wrap.remove(); }
    wrap.querySelectorAll('.js-close,.cm-back').forEach(b => b.addEventListener('click', close));

    function downloadURL(url, filename){
      const a = document.createElement('a'); a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
    }
    function getSvgDims(s){
      const mW = s.match(/width="([0-9.]+)"/), mH = s.match(/height="([0-9.]+)"/);
      const vb = s.match(/viewBox="\\s*([0-9.]+)\\s+([0-9.]+)\\s+([0-9.]+)\\s+([0-9.]+)\\s*"/);
      if (mW && mH) return { w: +mW[1], h: +mH[1] };
      if (vb) return { w: +vb[3], h: +vb[4] };
      return { w: 1000, h: 600 };
    }
    wrap.querySelector('.js-dl-svg').addEventListener('click', () => {
      const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
      downloadURL(URL.createObjectURL(blob), 'circuit.svg');
      setTimeout(()=>URL.revokeObjectURL(blob), 0);
    });
    wrap.querySelector('.js-dl-png').addEventListener('click', async () => {
      const { w, h } = getSvgDims(svg);
      const scale = 2;
      const canvas = document.createElement('canvas');
      canvas.width = Math.ceil(w * scale);
      canvas.height = Math.ceil(h * scale);
      const ctx = canvas.getContext('2d');
      const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      URL.revokeObjectURL(url);
      downloadURL(canvas.toDataURL('image/png'), 'circuit.png');
    });
    return wrap;
  }
</script>

<script type="module">
  const API = "https://polycode-ba.onrender.com";
  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");
  const gray = n => n ^ (n >> 1);

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = ""; varsEl.value = "";
    resEl.innerHTML = ""; ttCard.style.display = "none"; ttEl.innerHTML = "";
  });

  /* ---------- KMAP PARSING (Σ / Π / expr) ---------- */
  function parseKmapCommand(s){
    const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
    if (!mHdr) return null;
    const vars = mHdr[1].split(",").map(x=>x.trim());
    let rhs = mHdr[2].trim();

    // Optional don't-cares: ; d(…)
    let dontCares = [];
    const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
    if (mDC) { dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite); rhs = rhs.slice(0, mDC.index).trim(); }

    const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
    const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
    const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

    if (reSigma.test(rhs)) {
      const mm = reSigma.exec(rhs);
      const minterms = parseList(mm[1]);
      return { vars, mode:"ones", minterms, dontCares };
    }
    if (rePi.test(rhs)) {
      const mm = rePi.exec(rhs);
      const maxterms = parseList(mm[1]);
      const n = vars.length, U = Array.from({length:1<<n},(_,i)=>i);
      const bad = new Set([...maxterms, ...dontCares]);
      const minterms = U.filter(i => !bad.has(i)); // for grid display
      return { vars, mode:"zeros", maxterms, minterms, dontCares };
    }
    if (/^[0-9,\s]+$/.test(rhs)) {
      const minterms = parseList(rhs);
      return { vars, mode:"ones", minterms, dontCares };
    }
    return { vars, expr: rhs, dontCares };
  }

  /* ---------- BASIC GRID (compact HTML table) ---------- */
  function renderKmapTable(vars, minterms){
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;

    const grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
    for (let i=0; i<(1<<n); i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const rowLabels = Array.from({length:rows}, (_,r)=>(gray(r)>>>0).toString(2).padStart(rbits,'0'));
    const colLabels = Array.from({length:cols}, (_,c)=>(gray(c)>>>0).toString(2).padStart(cbits,'0'));

    const head =
      `<tr><th>${vars.slice(0,rbits).join("") || "&nbsp;"}</th>` +
      colLabels.map(l=>`<th>${vars.slice(rbits).join("")? vars.slice(rbits).join("")+"="+l : l}</th>`).join("") + `</tr>`;
    const body = grid.map((row,r) =>
      `<tr><th>${vars.slice(0,rbits).join("")? vars.slice(0,rbits).join("")+"="+rowLabels[r] : rowLabels[r]}</th>` +
      row.map(v=>`<td>${v}</td>`).join("") + `</tr>`
    ).join("");

    resEl.innerHTML = `
      <div class="mono">K-map (${n} vars): ${vars.join(", ")}</div>
      <table style="margin-top:8px"><thead>${head}</thead><tbody>${body}</tbody></table>
      <div class="muted" style="margin-top:8px">Tip: groups are powers of 2; wrap edges.</div>
    `;
  }

  /* ---------- BIG SVG KMAP WITH GROUPS (bridges + numbering) ---------- */
  function renderKmapSVG(vars, minterms, groups = [], title = "K-map", opts = {}) {
    const mode   = opts.mode ?? "ones";
    const scale  = opts.scale ?? 2.0;
    const cellW  = Math.round(42 * scale);
    const cellH  = Math.round(30 * scale);
    const pad    = Math.round(24 * scale);
    const font14 = Math.round(14 * scale);
    const font12 = Math.round(12 * scale);

    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;
    const gray = x => x ^ (x>>1);

    const grid = Array.from({length:rows},()=>Array(cols).fill(0));
    for (let i=0;i<(1<<n);i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const W = pad*2 + cols*cellW + 100, H = pad*2 + rows*cellH + 40;
    const X0 = pad, Y0 = pad, X1 = pad + cols*cellW, Y1 = pad + rows*cellH;

    function splitSegments(g){
      const rowsN = rows, colsN = cols;
      const r0 = ((g.r % rowsN) + rowsN) % rowsN;
      const c0 = ((g.c % colsN) + colsN) % colsN;
      const rh1 = Math.min(g.hr, rowsN - r0);
      const cw1 = Math.min(g.wr, colsN - c0);

      const segs = [{ r:r0, c:c0, hr:rh1, wr:cw1 }];
      if (g.wr > cw1) segs.push({ r:r0, c:0, hr:rh1, wr:g.wr - cw1 });
      if (g.hr > rh1){
        segs.push({ r:0, c:c0, hr:g.hr - rh1, wr:cw1 });
        if (g.wr > cw1) segs.push({ r:0, c:0, hr:g.hr - rh1, wr:g.wr - cw1 });
      }
      return { segs, r0, c0, wrapH: (c0 + g.wr) > colsN, wrapV: (r0 + g.hr) > rowsN };
    }

    const palette = ["#FF6B6B","#4DD0E1","#FFD166","#A78BFA","#26A69A","#F48FB1","#64B5F6","#FF8A65","#81C784","#E57373"];
    const dashAttr = (mode === "zeros") ? ` stroke-dasharray="${Math.round(6*scale)} ${Math.round(4*scale)}"` : "";

    const cells = grid.map((row,ri)=>
      row.map((v,ci)=>{
        const x = X0 + ci*cellW, y = Y0 + ri*cellH;
        return `<rect x="${x}" y="${y}" width="${cellW}" height="${cellH}" fill="none" stroke="currentColor" opacity="0.35"/>
                <text x="${x+cellW/2}" y="${y+cellH/2+font14/3}" text-anchor="middle"
                      class="mono" font-size="${font14}" fill="currentColor">${v}</text>`;
      }).join("")
    ).join("");

    const colLbl = Array.from({length:cols},(_,c)=> (gray(c)>>>0).toString(2).padStart(cbits,'0'))
      .map((l,i)=>`<text x="${X0 + i*cellW + cellW/2}" y="${Y0-6}" text-anchor="middle"
                    class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");
    const rowLbl = Array.from({length:rows},(_,r)=> (gray(r)>>>0).toString(2).padStart(rbits,'0'))
      .map((l,i)=>`<text x="${X0-6}" y="${Y0 + i*cellH + cellH/2+font12/3}"
                    text-anchor="end" class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");

    let rects = "", labels = "", bridges = "";
    groups.forEach((g,gi)=>{
      const color = palette[gi % palette.length];
      const { segs, r0, c0, wrapH, wrapV } = splitSegments(g);

      segs.forEach(s=>{
        const x = X0 + s.c*cellW, y = Y0 + s.r*cellH;
        const w = s.wr*cellW,    h = s.hr*cellH;
        rects += `<rect x="${x+2}" y="${y+2}" width="${w-4}" height="${h-4}"
                         rx="${Math.round(8*scale)}" fill="none"
                         stroke="${color}" stroke-width="2"${dashAttr}
                         vector-effect="non-scaling-stroke"/>`;
        labels += `<text x="${x + w/2}" y="${y + h/2 + font12/3}" text-anchor="middle"
                         class="mono" font-size="${font12}" fill="${color}">${gi+1}</text>`;
      });

      if (wrapH) {
        const yMid = Y0 + ((r0 + g.hr/2) % rows) * cellH;
        const L = Math.round(10 * scale);
        bridges += `<path d="M${X0-L},${yMid} H${X0}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
        bridges += `<path d="M${X1},${yMid} H${X1+L}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
      }
      if (wrapV) {
        const xMid = X0 + ((c0 + g.wr/2) % cols) * cellW;
        const L = Math.round(10 * scale);
        bridges += `<path d="M${xMid},${Y0-L} V${Y0}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
        bridges += `<path d="M${xMid},${Y1} V${Y1+L}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
      }
    });

    const subtitle = (mode === "zeros")
      ? `<div class="muted mono">Mode: POS — groups on 0-cells (dashed). Same color/number = one wrap-group.</div>`
      : `<div class="muted mono">Mode: SOP — groups on 1-cells. Same color/number = one wrap-group.</div>`;

    return `<div class="mono" style="margin:.5rem 0 .25rem">${title}</div>
            ${subtitle}
            <svg viewBox="0 0 ${W} ${H}" width="100%">
              <g fill="none" stroke="currentColor">${cells}</g>
              <g fill="currentColor">${colLbl}${rowLbl}</g>
              <g fill="none">${rects}</g>
              <g>${labels}</g>
              <g fill="none">${bridges}</g>
            </svg>`;
  }

  /* ---------- Circuit renderer (adds simple:true style) ---------- */
  function renderCircuitSVG(net, opts = {}) {
    const caption = opts.caption ?? "";
    let   scale   = opts.scale ?? "fit";
    const fitW    = opts.fitWidth ?? 1000;
    const zoom    = opts.zoom ?? 1.6;
    const simple  = !!opts.simple;              // NEW

    // Roomier geometry for student view
    const GW0= simple ? 76 : 72, GH0= simple ? 50 : 46, PIN0=10;
    const XSTEP0 = simple ? 200 : 180, YSTEP0 = simple ? 120 : 100, PAD0=28;

    const bubble = (x, y, s) =>
      `<circle cx="${x}" cy="${y}" r="${Math.round(6*s)}"
               stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;

    const gateAND = (x, y, s) => {
      const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
      const r = GH/2, xr = x + GW - r;
      return `<path d="M${x},${y} H${xr} A${r},${r} 0 0 1 ${xr},${y+GH} H${x} Z"
               stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
    };

    const gateOR = (x, y, s) => {
      const GW = Math.round(GW0*s), GH = Math.round(GH0*s);
      const xIn  = x + Math.round(12*s);
      const xOut = x + GW - Math.round(8*s);
      const yTop = y, yBot = y + GH, yMid = y + GH/2;
      const shell = `
        <path d="M${xIn},${yTop}
                 C ${x+GW*0.55},${yTop} ${x+GW*0.78},${yMid} ${xOut},${yMid}
                 C ${x+GW*0.78},${yMid} ${x+GW*0.55},${yBot} ${xIn},${yBot}
                 C ${x+6},${yBot-10} ${x+6},${yTop+10} ${xIn},${yTop}"
          stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
      const inner = `
        <path d="M${xIn - Math.round(8*s)},${yTop}
                 C ${x+GW*0.32},${yTop} ${x+GW*0.38},${yMid} ${xIn - Math.round(8*s)},${yBot}"
          stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
      return shell + inner;
    };

    const gateXOR = (x, y, s) => {
      const or = gateOR(x, y, s);
      const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
      const r  = GH/2, b=y+GH;
      const xIn2 = x + Math.round(2*s);
      const xm   = x + GW - Math.round(24*s);
      const extra =
        `<path d="M${xIn2},${y} C ${xm-32},${y} ${xm-10},${y+r} ${xIn2},${b}"
           stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
      return or + extra;
    };

    const gateNOT = (x, y, s) => {
      const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
      const tri = `<path d="M${x},${y} L${x},${y+GH} L${x+GW-12},${y+GH/2} Z"
                   stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;
      return tri + bubble(x + GW - 4*s, y + GH/2, s);
    };

    const nodes = new Map(), succ = new Map(), pred = new Map();
    const addNode = n => { nodes.set(n.id, n); succ.has(n.id)||succ.set(n.id,[]); pred.has(n.id)||pred.set(n.id,[]); };

    net.gates.forEach(g => addNode({...g}));
    net.inputs.forEach(i => addNode({ id:i.id, type:"IN", ins:[], label:i.label }));
    addNode({ id: net.output, type: nodes.get(net.output)?.type || "OUT", ins: nodes.get(net.output)?.ins || [] });

    nodes.forEach(n => (n.ins||[]).forEach(p => {
      if(!nodes.has(p)) addNode({id:p,type:"WIRE",ins:[]});
      succ.get(p).push(n.id); pred.get(n.id).push(p);
    }));

    const level = new Map();
    const lev = id => level.has(id) ? level.get(id)
      : level.set(id, (["IN","VCC","GND"].includes(nodes.get(id)?.type)) ? 0
        : Math.max(0,...(pred.get(id)||[]).map(lev))+1).get(id);
    nodes.forEach((_,id)=>lev(id));

    let layers=[]; level.forEach((v,id)=> (layers[v]||(layers[v]=[])).push(id));

    if (scale === "fit") {
      const baseW = (layers.length+1)*XSTEP0 + 2*PAD0;
      scale = Math.max(1.15, (fitW*zoom) / baseW);
    }
    const s = +scale;
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s), PIN=Math.round(PIN0*s);
    const XSTEP=Math.round(XSTEP0*s), YSTEP=Math.round(YSTEP0*s), PAD=Math.round(PAD0*s);

    const FAN_STUB = Math.round(12*s);
    const FAN_GAP  = Math.round(10*s);
    const ROW_CHAN_MARGIN = Math.round(20*s);
    const TRACK    = Math.round(14*s);
    const CLEAR    = Math.round(16*s);

    const abs = new Map(), rowIndex = new Map();
    layers.forEach((ids, lx) => ids.forEach((id, ly) => {
      abs.set(id, { x: PAD + lx*XSTEP, y: PAD + ly*YSTEP });
      rowIndex.set(id, ly);
    }));

    const width  = (layers.length+1)*XSTEP + 2*PAD;
    const height = Math.max(1,...layers.map(a=>a.length))*YSTEP + 2*PAD + (caption?Math.round(28*s):0);

    const pinY = (y,n,k)=> y + GH*((k+1)/(Math.max(1,n)+1));

    function drawGate(n){
      if (n.type==="WIRE") return "";
      const p=abs.get(n.id);

      if (n.type==="IN"){
        const r = Math.round(9*s);
        const cx = p.x + r, cy = p.y + r;
        const jack = `<line x1="${cx+r}" y1="${cy}" x2="${cx+r+PIN}" y2="${cy}"/>`;
        return `<g class="gate IN">
          <circle cx="${cx}" cy="${cy}" r="${r}" />
          ${jack}
          <text x="${p.x - Math.round(8*s)}" y="${cy + Math.round(5*s)}"
                text-anchor="end" class="mono inlabel">${n.label||n.id}</text>
        </g>`;
      }
      if (n.type==="OUT") return "";

      const nIns=(n.ins||[]).length||1;
      const pins = Array.from({length:nIns},(_,k)=>{
        const py = pinY(p.y, nIns, k);
        return `<line x1="${p.x-PIN}" y1="${py}" x2="${p.x}" y2="${py}"/>`;
      }).join("");

      const wrap = (cls,body)=>`<g class="gate ${cls}" color="currentColor">${pins}${body}</g>`;
      if (n.type==="NOT")  return wrap("NOT",  gateNOT(p.x,p.y,s));
      if (n.type==="AND")  return wrap("AND",  gateAND(p.x,p.y,s));
      if (n.type==="OR")   return wrap("OR",   gateOR(p.x,p.y,s));
      if (n.type==="XOR")  return wrap("XOR",  gateXOR(p.x,p.y,s));
      if (n.type==="NAND") return wrap("NAND", gateAND(p.x,p.y,s) + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
      if (n.type==="NOR")  return wrap("NOR",  gateOR(p.x,p.y,s)  + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
      if (n.type==="XNOR") return wrap("XNOR", gateXOR(p.x,p.y,s) + bubble(p.x+GW+Math.round(8*s), p.y+GH/2, s));
      return wrap("OTHER", `<rect x="${p.x}" y="${p.y}" width="${GW}" height="${GH}" rx="${Math.round(10*s)}"/>
                            <text x="${p.x+GW/2}" y="${p.y+GH/2+5}" text-anchor="middle" class="mono">${n.type}</text>`);
    }

    function outX(id){
      const t = nodes.get(id)?.type || "WIRE";
      const p = abs.get(id);
      if (t === "IN"){
        const r = Math.round(9*s);
        return (p.x + r + r + PIN);
      }
      return p.x + (t==="WIRE" ? Math.round(10*s) : GW);
    }

    function wiresTo(tid){
      const t   = nodes.get(tid);
      const dst = abs.get(tid);
      const xL  = dst.x, yT = dst.y;
      const ins = (t.ins || []);

      function rowObstacles(row, xA, xB, ignoreIds = new Set()){
        const lo = Math.min(xA, xB), hi = Math.max(xA, xB);
        const out = [];
        layers.forEach(ids => {
          ids.forEach(id => {
            if (ignoreIds.has(id)) return;
            if (rowIndex.get(id) !== row) return;
            const g = nodes.get(id);
            if (!g || g.type === "WIRE") return;
            const p = abs.get(id);
            const gx0 = p.x, gx1 = p.x + GW;
            if (Math.max(gx0, lo) < Math.min(gx1, hi)) out.push({ id, gx0, gx1 });
          });
        });
        out.sort((a,b)=>a.gx0 - b.gx0);
        return out;
      }

      return ins.map((sid, k) => {
        const sp    = abs.get(sid);
        const sType = nodes.get(sid)?.type;

        const x1 = outX(sid);
        const y1 = (sType === "IN") ? (sp.y + Math.round(9*s)) : (sp.y + GH/2);
        const x2 = xL;
        const y2 = pinY(yT, ins.length || 1, k);

        const outList    = succ.get(sid) || [];
        const outIdx     = Math.max(0, outList.indexOf(tid));
        const outCount   = Math.max(1, outList.length);
        const laneOffset = (outIdx - (outCount - 1)/2) * Math.round(10*s);

        const sameRow = rowIndex.get(sid) === rowIndex.get(tid);
        const start   = `M${x1},${y1} h${Math.round(12*s)} v${laneOffset}`;
        let path = start;
        let curY = y1 + laneOffset;

        if (sameRow) {
          let curX = x1 + Math.round(12*s);
          const ignore = new Set([sid, tid]);
          const obs = rowObstacles(rowIndex.get(tid), curX, x2, ignore);

          const detourUp = rowIndex.get(tid) > 0;
          const yDet = detourUp ? (curY - Math.round(16*s)) : (curY + Math.round(16*s));

          for (const o of obs) {
            if (o.gx0 <= curX) continue;
            path += ` H${o.gx0 - Math.round(16*s)} V${yDet} H${o.gx1 + Math.round(16*s)} V${curY}`;
            curX = o.gx1 + Math.round(16*s);
          }

          if (ins.length === 1) {
            if (curY !== y2) path += ` V${y2}`;
            path += ` H${x2}`;
            return path;
          }

          const bendX = x2 - Math.round(GW/3) - (k+1)*Math.round(14*s);
          path += ` H${bendX} V${y2} H${x2}`;
          return path;
        }

        const chanY = (sType === "IN")
          ? (sp.y + Math.round(9*s) + Math.round(20*s))
          : (sp.y + GH + Math.round(20*s));

        let curX = x1 + Math.round(12*s);
        path += ` V${chanY}`;
        const ignore = new Set([sid, tid]);
        const obs = rowObstacles(rowIndex.get(sid), curX, x2, ignore);
        for (const o of obs) {
          if (o.gx0 <= curX) continue;
          path += ` H${o.gx0 - Math.round(16*s)} H${o.gx1 + Math.round(16*s)}`;
          curX = o.gx1 + Math.round(16*s);
        }

        const bendX = x2 - Math.round(GW/3) - (k+1)*Math.round(14*s);
        path += ` H${bendX} V${y2} H${x2}`;
        return path;

      }).join(" ");
    }

    const wiresSVG = Array.from(nodes.values())
      .filter(n=>(n.ins||[]).length)
      .map(n=>`<path d="${wiresTo(n.id)}" class="wire"/>`)
      .join("");

    const gatesSVG = Array.from(nodes.values()).map(drawGate).join("");

    /* ---- THEME: student/monochrome when simple:true ---- */
    const stroke = simple ? "#000" : "#cfd7e1";
    const sw = simple ? Math.max(3.2, 3.2*+scale) : Math.max(2.8, 2.8*+scale);
    const labelFill = simple ? "#000" : "currentColor";

    const style = `
    <style>
      .mono { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: ${Math.max(12, Math.round(12*+scale))}px; fill:${labelFill}; }
      .wire { stroke: ${stroke}; stroke-width: ${sw}; stroke-linecap: round; stroke-linejoin: round; fill: none; }
      .gate line, .gate path, .gate rect, .gate circle { stroke-width: ${sw}; stroke-linecap: round; stroke-linejoin: round; fill: none; stroke:${stroke}; }
      .gate.IN circle { stroke:${stroke}; }
      .gate.IN .inlabel { fill:${stroke}; font-weight:${simple ? 600 : 700}; font-size:${Math.max(14, Math.round(14*+scale))}px; }
    </style>`;

    return `<svg viewBox="0 0 ${width} ${height}" width="100%" preserveAspectRatio="xMinYMin meet">
      ${style}
      <g class="gates">${gatesSVG}</g>
      <g class="wires">${wiresSVG}</g>
      ${caption ? `<g class="labels" fill="${labelFill}">
        <text x="${PAD}" y="${height - Math.round(10*+scale)}" class="mono">F = ${caption}</text>
      </g>` : ""}
    </svg>`;
  }

  const resultCard = document.querySelector("aside.card");

  async function drawCircuit(style){
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) { alert("Enter an expression"); return; }

    resEl.textContent = `Generating ${style.toUpperCase()} circuit…`;
    ttCard.style.display="none"; ttEl.innerHTML="";
    resultCard?.classList.add("wide");

    const r = await fetch(API + "/api/ba/netlist", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ expr: text, vars, style })
    });
    const j = await r.json();
    if (!j.ok) { resEl.innerHTML = `<span class="muted">Error: ${j.error}</span>`; return; }

    requestAnimationFrame(() => {
      const fitWidth = resultCard.getBoundingClientRect().width - 32;
      resEl.innerHTML = renderCircuitSVG(j, {
        caption: exprEl.value.trim(),
        scale: 'fit',
        fitWidth,
        zoom: 2.2,
        simple: true       // <-- show inline in student style too
      });
    });
  }

  // Existing NAND/NOR buttons (inline)
  $("#btnCircuitNAND").addEventListener("click", () => drawCircuit("nand"));
  $("#btnCircuitNOR").addEventListener("click", () => drawCircuit("nor"));

  /* ---------- NEW: Simply Draw (no simplification, modal) ---------- */
  $("#btnSimplyDraw").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) { alert("Enter an expression"); return; }

    resEl.textContent = "Generating circuit…";
    ttCard.style.display="none"; ttEl.innerHTML="";
    try {
      const r = await fetch(API + "/api/ba/netlist", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, style: "mixed" })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error || "netlist error");

      const fitWidth = (resultCard?.getBoundingClientRect().width || 960) - 32;
      const svgStr = renderCircuitSVG(j, {
        caption: text,
        scale: "fit",
        fitWidth,
        zoom: 2.0,
        simple: true
      });
      showSvgModal(svgStr, { title: "Circuit (as entered)" });
      resEl.innerHTML = "";
    } catch (e) {
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
    }
  });

  /* ---------- NEW: Simplify & Draw (simplify then modal) ---------- */
  $("#btnSimplifyAndDraw").addEventListener("click", async () => {
    const raw = exprEl.value.trim();
    if (!raw) { alert("Enter an expression"); return; }
    const vars = varsEl.value.trim()
      ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean)
      : undefined;

    resEl.textContent = "Preparing circuit…";
    ttCard.style.display="none"; ttEl.innerHTML="";

    try {
      const r1 = await fetch(API + "/api/ba/simplify", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ expr: raw, vars, includeTable: false })
      });
      const j1 = await r1.json();
      if (!j1.ok) throw new Error(j1.error || "simplify error");

      const pretty = j1.simplifiedSOP || j1.sop || raw;

      const r2 = await fetch(API + "/api/ba/netlist", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: pretty, vars: j1.vars, style: "mixed" })
      });
      const j2 = await r2.json();
      if (!j2.ok) throw new Error(j2.error || "netlist error");

      const fitWidth = (resultCard?.getBoundingClientRect().width || 960) - 32;
      const svgStr = renderCircuitSVG(j2, {
        caption: pretty,
        scale: "fit",
        fitWidth,
        zoom: 2.0,
        simple: true
      });
      showSvgModal(svgStr, { title: "Circuit (Simplified & Drawn)" });
      resEl.innerHTML = "";
    } catch (e) {
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
    }
  });

  /* ---------- SIMPLIFY (text & optional truth table) ---------- */
  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    const km = parseKmapCommand(text);
    if (km) {
      ttCard.style.display = "none"; ttEl.innerHTML = "";
      resEl.textContent = "Building K-map…";

      try {
        let displayMins = km.minterms;
        if (km.expr) {
          const r1 = await fetch(API + "/api/ba/simplify", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
          });
          const j1 = await r1.json();
          if (!j1.ok) throw new Error(j1.error || "simplify error");
          displayMins = j1.minterms;
        }

        const body =
          km.mode === "zeros"
            ? { vars: km.vars, mode: "zeros", maxterms: km.maxterms, full: true }
            : { vars: km.vars, mode: "ones",  minterms: displayMins, full: true };

        const r = await fetch(API + "/api/ba/kmap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const j = await r.json();
        if (!j.ok) throw new Error(j.error || "kmap error");

        const solGroups = dedupeRectsClient(j.solutionGroups || [], km.vars);

        resEl.innerHTML = renderKmapSVG(
          km.vars,
          displayMins,
          solGroups,
          j.mode === "zeros"
            ? `Solution (POS): ${j.simplified}`
            : `Solution (SOP): ${j.simplified}`,
          { mode: j.mode, scale: 2.2 }
        );
      } catch (e) {
        resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      }
      return;
    }

    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else {
        ttCard.style.display="none"; ttEl.innerHTML="";
      }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });

  /* ---------- KMAP Pairings & Solution (big SVG) ---------- */
  async function showKmapGroups() {
    const text = exprEl.value.trim();
    if (!text) { alert("Type a kmap command or an expression."); return; }

    let vars, mode = "ones", minterms, maxterms;
    const km = parseKmapCommand(text);

    if (km) {
      vars = km.vars;
      mode = km.mode;
      if (km.expr) {
        const r1 = await fetch(API + "/api/ba/simplify", {
          method:"POST", headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
        });
        const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
        minterms = j1.minterms;
      } else {
        minterms = km.minterms;
        maxterms = km.maxterms;
      }
    } else {
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars: varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
      vars = j1.vars; minterms = j1.minterms;
    }

    const body = (mode === "zeros")
      ? { vars, mode:"zeros", maxterms: maxterms ?? [], full: true }
      : { vars, mode:"ones",  minterms: minterms ?? [], full: true };

    const r2 = await fetch(API + "/api/ba/kmap", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    const j2 = await r2.json();
    if (!j2.ok) { resEl.innerHTML = `<span class="muted">Error: ${j2.error}</span>`; return; }

    const pairsRaw = (j2.allGroups || []).filter(g => g.hr*g.wr === 2);
    const pairs = dedupeRectsClient(pairsRaw, vars);
    const solution = dedupeRectsClient(j2.solutionGroups || [], vars);

    resEl.innerHTML =
      renderKmapSVG(vars, minterms ?? [], pairs, "All pairings (size 2)", { mode, scale: 2.0 }) +
      renderKmapSVG(vars, minterms ?? [], solution,
        mode === "zeros" ? `Solution (POS): ${j2.simplified}` : `Solution (SOP): ${j2.simplified}`,
        { mode, scale: 2.2 });
  }

  $("#btnKmapGroups").addEventListener("click", () => {
    ttCard.style.display="none"; ttEl.innerHTML="";
    resEl.textContent = "Analyzing K-map…";
    showKmapGroups().catch(e => resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`);
  });
</script>
</body>
</html>
