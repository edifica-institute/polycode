<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
 
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none } a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:auto; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
    .grid > .card.wide { grid-column: 1 / -1; }
    #result svg { max-height: none !important; width: 100%; height: auto; }
    aside.card.wide { padding-block: 24px; }
  </style>


    </head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">
          Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses.
          Implicit AND allowed, e.g., <b>AB + A~C</b>.
          K-map commands: <b>kmap A,B,C : Σm(1,3,5)</b>, <b>kmap A,B : ΠM(0,2)</b>, or <b>kmap A,B,C : AB + A'C</b>.
        </p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>
          <!-- NEW: teaching-safe buttons -->
          <button class="btn secondary" id="btnSimplifyDraw">Simplify &amp; Draw</button>
          <button class="btn secondary" id="btnSimplyDraw">Simply Draw</button>
          <!-- legacy circuit modes kept for now -->
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>
          <button class="btn secondary" id="btnKmapGroups">K-map Pairings &amp; Solution</button>
          <button class="btn secondary" id="btnClear">Clear</button>



          <h1>Boolean Logic Visualizer</h1>

 <input id="logicExpr" placeholder="A + B'C" />
<button id="renderBtn" type="button">Render</button>
<div id="logicMount"></div>


  <div id="logicMount" style="width:100%;max-width:980px;margin:12px auto;"></div>

HELLO ->
          <div id="gvMount" style="width:100%;max-width:980px;margin:12px auto;"></div>
        </div>
        
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>









  
<script src="./js/boolean-logic-svg.js" defer></script>
<script>
  // OPTIONAL: if you kept normalizeExpr from earlier patches
  const normalizeExpr = (s) => String(s||'')
    .replace(/[’‘`´]/g, "'")
    .replace(/[·•⋅]/g, '·')
    .replace(/\s+/g, ' ')
    .trim();

  window.addEventListener('DOMContentLoaded', () => {
    const input  = document.getElementById('logicExpr');
    const mount  = document.getElementById('logicMount');
    const button = document.getElementById('renderBtn');

    const render = () => {
      // If you ever switch to a <textarea> or contenteditable, this still works
      const val = ('value' in input ? input.value : input.textContent) || '';
      const expr = normalizeExpr ? normalizeExpr(val) : val.trim();

      console.log('draw expr =', JSON.stringify(expr)); // debug
      drawLogic(expr, mount); // pass the DOM node (removes selector ambiguity)
    };

    button.addEventListener('click', (e) => { e.preventDefault(); render(); });
  });
</script>


















  
<script type="module">
  const API = "https://polycode-ba.onrender.com";
  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");
  const gray = n => n ^ (n >> 1);

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = ""; varsEl.value = "";
    resEl.innerHTML = ""; ttCard.style.display = "none"; ttEl.innerHTML = "";
  });

  /* ---------- KMAP parsing (unchanged) ---------- */
  function parseKmapCommand(s){
    const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
    if (!mHdr) return null;
    const vars = mHdr[1].split(",").map(x=>x.trim());
    let rhs = mHdr[2].trim();

    let dontCares = [];
    const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
    if (mDC) { dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite); rhs = rhs.slice(0, mDC.index).trim(); }

    const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
    const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
    const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

    if (reSigma.test(rhs)) {
      const mm = reSigma.exec(rhs);
      const minterms = parseList(mm[1]);
      return { vars, mode:"ones", minterms, dontCares };
    }
    if (rePi.test(rhs)) {
      const mm = rePi.exec(rhs);
      const maxterms = parseList(mm[1]);
      const n = vars.length, U = Array.from({length:1<<n},(_,i)=>i);
      const bad = new Set([...maxterms, ...dontCares]);
      const minterms = U.filter(i => !bad.has(i));
      return { vars, mode:"zeros", maxterms, minterms, dontCares };
    }
    if (/^[0-9,\s]+$/.test(rhs)) {
      const minterms = parseList(rhs);
      return { vars, mode:"ones", minterms, dontCares };
    }
    return { vars, expr: rhs, dontCares };
  }

  /* ---------- Teaching-safe simple circuit renderer ---------- */
  // Layout: strict columns, fixed spacing, straight wires into gate faces.
/* ---------- Teaching-safe simple circuit renderer (no crossings, 90° only) ---------- */
function renderSimpleCircuitSVG(net, caption = "") {
  const GW=64, GH=40, PIN=10, XSTEP=140, YSTEP=70, PAD=24;
  const textSize = 14;

  // Build nodes/graph
  const nodes = new Map(), succ = new Map(), pred = new Map();
  const addNode = n => { nodes.set(n.id, n); succ.has(n.id)||succ.set(n.id,[]); pred.has(n.id)||pred.set(n.id,[]); };
  net.gates.forEach(g => addNode({...g}));
  net.inputs.forEach(i => addNode({ id:i.id, type:"IN", ins:[], label:i.label }));
  // OUT node present for topology but we'll not draw its incoming wire
  addNode({ id: net.output, type:"OUT", ins: nodes.get(net.output)?.ins || [] });
  nodes.forEach(n => (n.ins||[]).forEach(p => { if(!nodes.has(p)) addNode({id:p,type:"WIRE",ins:[]}); succ.get(p).push(n.id); pred.get(n.id).push(p); }));

  // Longest-path levels
  const level = new Map();
  const lev = id => level.has(id) ? level.get(id)
    : level.set(id, (["IN","VCC","GND"].includes(nodes.get(id)?.type)) ? 0
      : Math.max(0,...(pred.get(id)||[]).map(lev))+1).get(id);
  nodes.forEach((_,id)=>lev(id));

  // Pack per level
  const layers=[]; level.forEach((v,id)=> (layers[v]||(layers[v]=[])).push(id));
  const abs = new Map();
  layers.forEach((ids, lx) => ids.forEach((id, ly) => {
    abs.set(id, { x: PAD + lx*XSTEP, y: PAD + ly*YSTEP });
  }));

  const width  = (layers.length+1)*XSTEP + 2*PAD;
  const height = Math.max(1,...layers.map(a=>a.length))*YSTEP + 2*PAD + (caption?28:0);
  const pinY = (y,n,k)=> y + GH*((k+1)/(Math.max(1,n)+1));

  // Gate glyphs (classic)
  const bubble = (x,y,r=6)=>`<circle cx="${x}" cy="${y}" r="${r}" fill="none" stroke="currentColor"/>`;
  const gAND = (x,y)=>`<path d="M${x},${y} H${x+GW/2} A${GH/2},${GH/2} 0 0 1 ${x+GW/2},${y+GH} H${x} Z" fill="none" stroke="currentColor"/>`;
  const gOR  = (x,y)=>`
    <path d="M${x+10},${y}
             C ${x+GW*0.55},${y} ${x+GW*0.78},${y+GH/2} ${x+GW-10},${y+GH/2}
             C ${x+GW*0.78},${y+GH/2} ${x+GW*0.55},${y+GH} ${x+10},${y+GH}
             C ${x+4},${y+GH-10} ${x+4},${y+10} ${x+10},${y}"
          fill="none" stroke="currentColor"/>`;
  const gXOR = (x,y)=> gOR(x,y) + `<path d="M${x+4},${y} C ${x+GW*0.32},${y} ${x+GW*0.38},${y+GH/2} ${x+4},${y+GH}"
                                   fill="none" stroke="currentColor"/>`;
  const gNOT = (x,y)=>`<path d="M${x},${y} L${x},${y+GH} L${x+GW-14},${y+GH/2} Z" fill="none" stroke="currentColor"/>` + bubble(x+GW-6, y+GH/2, 6);
  const gNAND= (x,y)=> gAND(x,y) + bubble(x+GW, y+GH/2, 6);
  const gNOR = (x,y)=> gOR(x,y)  + bubble(x+GW, y+GH/2, 6);
  const gXNOR= (x,y)=> gXOR(x,y) + bubble(x+GW, y+GH/2, 6);

  function drawGate(n){
    if (n.type==="WIRE" || n.type==="OUT") return "";
    const p = abs.get(n.id);
    const nIns=(n.ins||[]).length||1;
    const pins = Array.from({length:nIns},(_,k)=>{
      const py = pinY(p.y, nIns, k);
      return `<line x1="${p.x-10}" y1="${py}" x2="${p.x}" y2="${py}" stroke="currentColor"/>`;
    }).join("");

    if (n.type === "IN") {
      const r=9, cx=p.x+r, cy=p.y+r;
      return `<g class="gate IN">
        <circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="currentColor"/>
        <line x1="${cx+r}" y1="${cy}" x2="${cx+r+PIN}" y2="${cy}" stroke="currentColor"/>
        <text x="${p.x-8}" y="${cy+5}" text-anchor="end" class="mono" font-size="${textSize}" fill="currentColor">${n.label||n.id}</text>
      </g>`;
    }

    const body = {
      "AND": gAND(p.x,p.y), "OR": gOR(p.x,p.y), "XOR": gXOR(p.x,p.y), "NOT": gNOT(p.x,p.y),
      "NAND": gNAND(p.x,p.y), "NOR": gNOR(p.x,p.y), "XNOR": gXNOR(p.x,p.y)
    }[n.type] || `<rect x="${p.x}" y="${p.y}" width="${GW}" height="${GH}" rx="10" fill="none" stroke="currentColor"/>`;

    return `<g class="gate ${n.type}">${pins}${body}</g>`;
  }

  const outX = id => {
    const t = nodes.get(id)?.type || "WIRE";
    const p = abs.get(id);
    if (t === "IN"){ const r = 9; return p.x + r + r + PIN; }
    return p.x + GW;
  };

  // H-only (same row) OR H–V–H via a spine left of the destination gate column.
  function wiresTo(tid){
    const t   = nodes.get(tid);
    const dst = abs.get(tid);
    const xGateLeft = dst.x;          // gate’s left face
    const SPINE = xGateLeft - 28;     // routing spine (guaranteed left of body)
    const ins = (t.ins || []);

    return ins.map((sid, k) => {
      const sp = abs.get(sid);
      const y1 = (nodes.get(sid)?.type === "IN") ? sp.y + 9 : sp.y + GH/2;
      const y2 = pinY(dst.y, ins.length || 1, k);
      const x1 = outX(sid);

      if (Math.abs(y1 - y2) < 1e-6) {
        // same row: straight into pin (no unnecessary bends)
        return `M${x1},${y1} H${xGateLeft}`;
      }
      // Route outside symbols: H to spine, V to target row, H into pin
      return `M${x1},${y1} H${SPINE} V${y2} H${xGateLeft}`;
    }).join(" ");
  }

  const gatesSVG = Array.from(nodes.values()).map(drawGate).join("");
  // Draw all wires EXCEPT into the OUT node (we’ll make one final output line)
  const wiresSVG = Array.from(nodes.values())
    .filter(n => (n.ins||[]).length && n.id !== net.output)
    .map(n=>`<path d="${wiresTo(n.id)}" stroke="currentColor" fill="none" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"/>`)
    .join("");

  // Single clean output line to the lamp
  const lastSrc = (pred.get(net.output) || [])[0];
  const lastSrcPos = abs.get(lastSrc) || { x: width-80, y: height/2 };
  const yOut = (nodes.get(lastSrc)?.type === "IN") ? lastSrcPos.y + 9 : lastSrcPos.y + GH/2;
  const xOutStart = outX(lastSrc);
  const lampX = (abs.get(net.output)?.x || (PAD + (layers.length)*XSTEP)) + GW + 50;
  const lampY = (abs.get(net.output)?.y || (height/2)) + GH/2;

  const outputLine = `<path d="M${xOutStart},${yOut} H${lampX-36}" stroke="currentColor" fill="none" stroke-width="2.6" stroke-linecap="round" />`;
  const lamp = `
    <g transform="translate(${lampX-36}, ${lampY-18})" stroke="currentColor" fill="none">
      <path d="M0,18 C0,8 8,0 18,0 C28,0 36,8 36,18 C36,26 31,31 27,34 L24,42 H12 L9,34 C5,31 0,26 0,18 Z" />
      <circle cx="18" cy="18" r="12" />
    </g>`;

  const style = `
    <style>
      .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
      text { font-size: ${textSize}px; }
    </style>`;

  const captionSVG = caption ? `<text x="${PAD}" y="${height-8}" class="mono" fill="currentColor">F = ${caption}</text>` : "";

  return `<svg viewBox="0 0 ${width+160} ${height}" width="100%" preserveAspectRatio="xMinYMin meet">
    ${style}
    <g>${gatesSVG}</g>
    <g>${wiresSVG}${outputLine}</g>
    ${lamp}
    ${captionSVG}
  </svg>`;
}


  /* ---------- Existing: Simplify / K-map / TT ---------- */
  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    // K-map command?
    const km = parseKmapCommand(text);
    if (km) {
      ttCard.style.display = "none"; ttEl.innerHTML = "";
      resEl.textContent = "Building K-map…";
      try {
        let displayMins = km.minterms;
        if (km.expr) {
          const r1 = await fetch(API + "/api/ba/simplify", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
          });
          const j1 = await r1.json();
          if (!j1.ok) throw new Error(j1.error || "simplify error");
          displayMins = j1.minterms;
        }
        const body = km.mode === "zeros"
          ? { vars: km.vars, mode: "zeros", maxterms: km.maxterms, full: true }
          : { vars: km.vars, mode: "ones",  minterms: displayMins, full: true };

        const r = await fetch(API + "/api/ba/kmap", {
          method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body)
        });
        const j = await r.json(); if (!j.ok) throw new Error(j.error || "kmap error");

        resEl.innerHTML = `
          <div class="mono" style="margin-bottom:6px">${j.mode==="zeros" ? `Solution (POS): ${j.simplified}` : `Solution (SOP): ${j.simplified}`}</div>
          <!-- K-map SVG could be injected here (omitted to keep focus on circuit clarity) -->
        `;
      } catch (e) { resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`; }
      return;
    }

    // Otherwise, normal simplify flow
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else { ttCard.style.display="none"; ttEl.innerHTML=""; }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });

  /* ---------- NEW buttons: Simplify & Draw / Simply Draw ---------- */
  async function fetchNetlist(expr, vars, style="mixed") {
    const r = await fetch(API + "/api/ba/netlist", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ expr, vars, style })
    });
    const j = await r.json();
    if (!j.ok) throw new Error(j.error || "netlist error");
    return j;
  }

  $("#btnSimplifyDraw").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) { alert("Enter an expression"); return; }
    resEl.textContent = "Simplifying…";
    try {
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error || "simplify error");
      const net = await fetchNetlist(j1.simplifiedSOP || j1.simplified || text, vars, "mixed");
      resEl.innerHTML = renderSimpleCircuitSVG(net, j1.simplifiedSOP || j1.simplified || text);
    } catch (e) { resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`; }
  });

  $("#btnSimplyDraw").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) { alert("Enter an expression"); return; }
    resEl.textContent = "Drawing…";
    try {
      const net = await fetchNetlist(text, vars, "mixed");
      resEl.innerHTML = renderSimpleCircuitSVG(net, text);
    } catch (e) { resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`; }
  });

  // Keep NAND/NOR buttons for parity (they’ll also use the simple renderer)
  $("#btnCircuitNAND").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) return alert("Enter an expression");
    resEl.textContent = "Drawing (NAND)…";
    try {
      const net = await fetchNetlist(text, vars, "nand");
      resEl.innerHTML = renderSimpleCircuitSVG(net, text + "  (NAND)");
    } catch(e){ resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`; }
  });
  $("#btnCircuitNOR").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) return alert("Enter an expression");
    resEl.textContent = "Drawing (NOR)…";
    try {
      const net = await fetchNetlist(text, vars, "nor");
      resEl.innerHTML = renderSimpleCircuitSVG(net, text + "  (NOR)");
    } catch(e){ resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`; }
  });

  /* ---------- (Optional) K-map groups button stays wired to your API ---------- */
  $("#btnKmapGroups").addEventListener("click", () => {
    ttCard.style.display="none"; ttEl.innerHTML="";
    resEl.textContent = "Analyzing K-map… (renderer simplified for teaching)";
  });
</script>










<!-- Viz.js (client Graphviz) -->
<script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/viz.js"></script>
<script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/full.render.js"></script>



<script>
const gateStroke = '#9ecbff';
const wireColor  = '#e9edf3';
const fillPanel  = '#1e2024';
const bg         = '#0b0f13';
const font       = 'Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial';

const NOT_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="34">
  <path d="M6 4 L6 30 L40 17 Z" fill="${fillPanel}" stroke="${gateStroke}" stroke-width="2"/>
  <circle cx="48" cy="17" r="5.5" fill="${bg}" stroke="${gateStroke}" stroke-width="2"/>
</svg>`;

const AND_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" width="90" height="44">
  <path d="M6 4 H46 C78 4,78 40,46 40 H6 Z" fill="${fillPanel}" stroke="${gateStroke}" stroke-width="2"/>
</svg>`;

const OR_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" width="96" height="60">
  <path d="M10 4 C30 4,58 4,76 16 C92 28,92 44,76 56 C58 68,30 68,10 68
           C28 52,28 20,10 4 Z"
        transform="translate(0,-8)" fill="${fillPanel}" stroke="${gateStroke}" stroke-width="2"/>
</svg>`;

// We use image= on nodes (supported by viz.js "images" option), and separate point ports.
const dot = `
digraph G {
  graph [rankdir=LR, bgcolor="${bg}", splines=ortho, nodesep="0.6", ranksep="0.9"];
  edge  [color="${wireColor}", penwidth=2, arrowhead=none];
  node  [fontname="${font}", color="${gateStroke}", fontcolor="${gateStroke}"];

  // inputs/outputs
  A [shape=circle, label="A", fontcolor="${wireColor}"];
  B [shape=circle, label="B", fontcolor="${wireColor}"];
  C [shape=circle, label="C", fontcolor="${wireColor}"];
  Y [shape=circle, label="Y", fontcolor="${wireColor}"];

  // --- NOT gate group (image + ports) ---
  NOT_img  [shape=none, label="", image="not.svg", imagescale=true, fixedsize=true, width=0.9, height=0.5];
  NOT_in   [shape=point, label="", width=0.02];
  NOT_out  [shape=point, label="", width=0.02];
  // keep them in a row
  {rank=same; NOT_in -> NOT_img [style=invis, weight=100, arrowhead=none];
              NOT_img -> NOT_out [style=invis, weight=100, arrowhead=none];}

  // --- AND gate group ---
  AND_img  [shape=none, label="", image="and.svg", imagescale=true, fixedsize=true, width=1.0, height=0.55];
  AND_in1  [shape=point, label="", width=0.02];
  AND_in2  [shape=point, label="", width=0.02];
  AND_out  [shape=point, label="", width=0.02];
  {rank=same; AND_in1 -> AND_img [style=invis, weight=100, arrowhead=none];
              AND_img -> AND_out [style=invis, weight=100, arrowhead=none];}
  // put AND_in2 under AND_in1: use same x via an invisible edge with constraint=false
  AND_in2 -> AND_in1 [style=invis, constraint=false];

  // --- OR gate group ---
  OR_img   [shape=none, label="", image="or.svg", imagescale=true, fixedsize=true, width=1.05, height=0.75];
  OR_in1   [shape=point, label="", width=0.02];
  OR_in2   [shape=point, label="", width=0.02];
  OR_out   [shape=point, label="", width=0.02];
  {rank=same; OR_in1 -> OR_img [style=invis, weight=100, arrowhead=none];
              OR_img -> OR_out [style=invis, weight=100, arrowhead=none];}
  OR_in2 -> OR_in1 [style=invis, constraint=false];

  // column ranks
  {rank=same; A; B; C}
  {rank=same; NOT_in; NOT_img; NOT_out; AND_in1; AND_img; AND_out}
  {rank=same; OR_in1; OR_img; OR_out; Y}

  // wires (all orthogonal)
  B -> NOT_in;
  NOT_out -> AND_in1;
  C -> AND_in2;
  AND_out -> OR_in2;
  A -> OR_in1;
  OR_out -> Y;
}
`;

const viz = new Viz();
viz.renderSVGElement(dot, {
  images: [
    { path: 'not.svg', data: NOT_SVG, width: 64, height: 34 },
    { path: 'and.svg', data: AND_SVG, width: 90, height: 44 },
    { path: 'or.svg',  data: OR_SVG,  width: 96, height: 60 }
  ]
}).then(svg => {
  const m = document.getElementById('gvMount');
  m.innerHTML = ''; svg.style.maxWidth = '100%'; m.appendChild(svg);
}).catch(err => {
  console.error(err);
  document.getElementById('gvMount').textContent = 'Graphviz render error: ' + err.message;
});
</script>








  
  
</body>
</html>
