<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none }
    a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:auto; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses. Implicit AND allowed, e.g., <b>AB + A~C</b>. K-map commands: <b>kmap A,B,C : Σm(1,3,5)</b> or <b>kmap A,B : ΠM(0,2)</b>, or <b>kmap A,B,C : AB + A'C</b>.</p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>
          <button class="btn secondary" id="btnCircuit">Circuit</button>
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>
          <button class="btn secondary" id="btnKmapGroups">K-map Pairings &amp; Solution</button>
          <button class="btn secondary" id="btnClear">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>

<script type="module">
  const API = "https://polycode-ba.onrender.com";
  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");
  const gray = n => n ^ (n >> 1);

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = ""; varsEl.value = "";
    resEl.innerHTML = ""; ttCard.style.display = "none"; ttEl.innerHTML = "";
  });

  /* ---------- KMAP PARSING (Σ / Π / expr) ---------- */
  function parseKmapCommand(s){
    const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
    if (!mHdr) return null;

    const vars = mHdr[1].split(",").map(x=>x.trim());
    let rhs = mHdr[2].trim();

    // Optional don't-cares: ; d(…)
    let dontCares = [];
    const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
    if (mDC) { dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite); rhs = rhs.slice(0, mDC.index).trim(); }

    const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
    const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
    const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

    if (reSigma.test(rhs)) {
      const mm = reSigma.exec(rhs);
      const minterms = parseList(mm[1]);
      return { vars, mode:"ones", minterms, dontCares };
    }
    if (rePi.test(rhs)) {
      const mm = rePi.exec(rhs);
      const maxterms = parseList(mm[1]);
      const n = vars.length, U = Array.from({length:1<<n},(_,i)=>i);
      const bad = new Set([...maxterms, ...dontCares]);
      const minterms = U.filter(i => !bad.has(i));                      // for grid display
      return { vars, mode:"zeros", maxterms, minterms, dontCares };
    }
    if (/^[0-9,\s]+$/.test(rhs)) {
      const minterms = parseList(rhs);
      return { vars, mode:"ones", minterms, dontCares };
    }
    return { vars, expr: rhs, dontCares };
  }

  /* ---------- BASIC GRID (compact HTML table) ---------- */
  function renderKmapTable(vars, minterms){
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;

    const grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
    for (let i=0; i<(1<<n); i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const rowLabels = Array.from({length:rows}, (_,r)=>(gray(r)>>>0).toString(2).padStart(rbits,'0'));
    const colLabels = Array.from({length:cols}, (_,c)=>(gray(c)>>>0).toString(2).padStart(cbits,'0'));

    const head =
      `<tr><th>${vars.slice(0,rbits).join("") || "&nbsp;"}</th>` +
      colLabels.map(l=>`<th>${vars.slice(rbits).join("")? vars.slice(rbits).join("")+"="+l : l}</th>`).join("") + `</tr>`;
    const body = grid.map((row,r) =>
      `<tr><th>${vars.slice(0,rbits).join("")? vars.slice(0,rbits).join("")+"="+rowLabels[r] : rowLabels[r]}</th>` +
      row.map(v=>`<td>${v}</td>`).join("") + `</tr>`
    ).join("");

    resEl.innerHTML = `
      <div class="mono">K-map (${n} vars): ${vars.join(", ")}</div>
      <table style="margin-top:8px"><thead>${head}</thead><tbody>${body}</tbody></table>
      <div class="muted" style="margin-top:8px">Tip: groups are powers of 2; wrap edges.</div>
    `;
  }

  /* ---------- BIG SVG KMAP WITH GROUPS ---------- */
  function renderKmapSVG(vars, minterms, groups = [], title = "K-map", opts = {}) {
    const mode   = opts.mode ?? "ones";
    const scale  = opts.scale ?? 2.2;
    const cellW  = Math.round(42 * scale);
    const cellH  = Math.round(30 * scale);
    const pad    = Math.round(24 * scale);
    const font14 = Math.round(14 * scale);
    const font12 = Math.round(12 * scale);

    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;

    const grid = Array.from({length:rows},()=>Array(cols).fill(0));
    for (let i=0;i<(1<<n);i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const W = pad*2 + cols*cellW + 100, H = pad*2 + rows*cellH + 40;

    const rects = groups.map(g=>{
      const x = pad + g.c*cellW, y = pad + g.r*cellH;
      const w = g.wr*cellW,      h = g.hr*cellH;
      const dash = (mode === "zeros") ? ` stroke-dasharray="${Math.round(6*scale)} ${Math.round(4*scale)}"` : "";
      return `<rect x="${x+2}" y="${y+2}" width="${w-4}" height="${h-4}" rx="${Math.round(8*scale)}"
                     fill="none" stroke="currentColor" stroke-width="2"${dash}
                     vector-effect="non-scaling-stroke"/>`;
    }).join("");

    const cells = grid.map((row,ri)=>
      row.map((v,ci)=>{
        const x = pad + ci*cellW, y = pad + ri*cellH;
        return `<rect x="${x}" y="${y}" width="${cellW}" height="${cellH}" fill="none" stroke="currentColor" opacity="0.35"/>
                <text x="${x+cellW/2}" y="${y+cellH/2+font14/3}" text-anchor="middle"
                      class="mono" font-size="${font14}" fill="currentColor">${v}</text>`;
      }).join("")
    ).join("");

    const colLbl = Array.from({length:cols},(_,c)=> (gray(c)>>>0).toString(2).padStart(cbits,'0'))
      .map((l,i)=>`<text x="${pad + i*cellW + cellW/2}" y="${pad-6}" text-anchor="middle"
                       class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");
    const rowLbl = Array.from({length:rows},(_,r)=> (gray(r)>>>0).toString(2).padStart(rbits,'0'))
      .map((l,i)=>`<text x="${pad-6}" y="${pad + i*cellH + cellH/2+font12/3}"
                       text-anchor="end" class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");

    const subtitle = (mode === "zeros")
      ? `<div class="muted mono">Mode: POS — groups on 0-cells (dashed)</div>`
      : `<div class="muted mono">Mode: SOP — groups on 1-cells</div>`;

    return `<div class="mono" style="margin:.5rem 0 .25rem">${title}</div>
            ${subtitle}
            <svg viewBox="0 0 ${W} ${H}" width="100%">
              <g fill="none" stroke="currentColor">${cells}${rects}</g>
              <g fill="currentColor">${colLbl}${rowLbl}</g>
            </svg>`;
  }

  /* ---------- SIMPLIFY button ---------- */
  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    // K-map command?
    const km = parseKmapCommand(text);
    if (km) {
      ttCard.style.display = "none"; ttEl.innerHTML = "";
      resEl.textContent = "Building K-map…";
      try {
        // If user gave an expr after "kmap", get minterms to draw the grid with F-values
        let minForGrid = km.minterms;
        if (km.expr) {
          const r1 = await fetch(API + "/api/ba/simplify", {
            method:"POST", headers:{ "Content-Type":"application/json" },
            body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
          });
          const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error || "simplify error");
          minForGrid = j1.minterms;
        }
        renderKmapTable(km.vars, minForGrid);
      } catch (e) {
        resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      }
      return;
    }

    // Otherwise, normal simplify flow
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else {
        ttCard.style.display="none"; ttEl.innerHTML="";
      }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });

  /* ---------- CIRCUIT SVG (ANSI/IEC shapes, fit-to-width, caption) ---------- */
// Orthogonal (Manhattan) circuit renderer with barycenter ordering + fit-to-width
// -----------------------------------------------------------------------------
// Manhattan (90°) logic renderer with Sugiyama-style layout:
// - Splits long edges into per-layer "WIRE" nodes
// - 4 barycenter sweeps (forward + reverse) to reduce crossings
// - Orthogonal H-V-H routing with per-input vertical tracks
// - Fit-to-width scaling (opts.scale='fit', opts.fitWidth)
// -----------------------------------------------------------------------------
function renderCircuitSVG(net, opts = {}) {
  const caption = opts.caption ?? "";
  let   scale   = opts.scale ?? 'fit';         // 'fit' or number
  const fitW    = opts.fitWidth ?? 980;

  // ---------- Constants (base, pre-scale) ----------
  const GW0=72, GH0=46, PIN0=10, XSTEP0=180, YSTEP0=100, PAD0=28;

  // ---------- Shapes (ANSI/IEC-ish) ----------
  const bubble = (x, y, s) =>
    `<circle cx="${x}" cy="${y}" r="${Math.round(6*s)}" stroke="currentColor"
             fill="var(--panel,transparent)" vector-effect="non-scaling-stroke"/>`;

  const gateAND = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const r = GH/2, xr = x + GW - r;
    return `<path d="M${x},${y} H${xr} A${r},${r} 0 0 1 ${xr},${y+GH} H${x} Z"
             fill="var(--panel,transparent)" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
  };
  const gateOR = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const xIn = x + Math.round(14*s), xOut = x + GW - Math.round(10*s);
    const xm  = x + GW - Math.round(22*s), b = y + GH;
    return `<path d="M${xIn},${y}
                     C ${xm-22},${y} ${xm},${y+GH/2} ${xOut},${y+GH/2}
                     C ${xm},${y+GH/2} ${xm-22},${b} ${xIn},${b}
                     C ${x+6},${b-10} ${x+6},${y+10} ${xIn},${y}"
             fill="var(--panel,transparent)" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
  };
  const gateXOR = (x, y, s) => {
    const or = gateOR(x, y, s);
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const xIn = x + Math.round(8*s), xm = x + GW - Math.round(22*s), b=y+GH;
    const extra = `<path d="M${xIn},${y} C ${xm-22},${y} ${xm},${y+GH/2} ${xIn},${b}"
                   fill="none" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
    return or + extra;
  };
  const gateNOT = (x, y, s) => {
    const GW=Math.round(GW0*s), GH=Math.round(GH0*s);
    const tri = `<path d="M${x},${y} L${x},${y+GH} L${x+GW-12},${y+GH/2} Z"
                 fill="var(--panel,transparent)" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
    return tri + bubble(x + GW - 4*s, y + GH/2, s);
  };

  // ---------- Build graph ----------
  const nodes = new Map();       // id -> { id, type, ins[], label? }
  const succ  = new Map();       // id -> [children]
  const pred  = new Map();       // id -> [parents]

  function addNode(n){ nodes.set(n.id, n); if (!succ.has(n.id)) succ.set(n.id, []); if (!pred.has(n.id)) pred.set(n.id, []); }

  // gates + inputs + output "anchor"
  net.gates.forEach(g => addNode({...g}));
  net.inputs.forEach(i => addNode({ id:i.id, type:"IN", ins:[], label:i.label }));
  addNode({ id: net.output, type: nodes.get(net.output)?.type || "OUT", ins: nodes.get(net.output)?.ins || [] });

  // Build raw edges from ins -> gate
  nodes.forEach(n => {
    (n.ins||[]).forEach(p => {
      if (!nodes.has(p)) addNode({id:p, type:"WIRE", ins:[ ]}); // safety
      succ.get(p).push(n.id);
      pred.get(n.id).push(p);
    });
  });

  // ---------- Longest-path levels (initial layering) ----------
  const level = new Map();
  const dfsLevel = (id) => {
    if (level.has(id)) return level.get(id);
    const n = nodes.get(id);
    const v = (n.type==="IN" || id==="VCC_1" || id==="GND_0") ? 0
            : Math.max(0, ...(pred.get(id)||[]).map(dfsLevel)) + 1;
    level.set(id, v); return v;
  };
  nodes.forEach((_,id)=>dfsLevel(id));

  // ---------- Split long edges into per-layer "WIRE" nodes ----------
  let wireSerial = 0;
  function newWireId(){ return `_W${wireSerial++}`; }

  pred.forEach((parents, child)=>{
    const lc = level.get(child);
    parents.slice().forEach(p=>{
      const lp = level.get(p);
      if (lc - lp <= 1) return; // already adjacent

      // remove old edge p -> child
      succ.set(p, (succ.get(p) || []).filter(x=>x!==child));
      pred.set(child, (pred.get(child) || []).filter(x=>x!==p));

      // chain of virtual nodes one per intermediate layer
      let prev = p;
      for (let L = lp+1; L < lc; L++){
        const wid = newWireId();
        addNode({ id: wid, type:"WIRE", ins:[prev] });
        level.set(wid, L);
        succ.get(prev).push(wid);
        pred.get(wid).push(prev);
        prev = wid;
      }
      // connect last virtual to child
      succ.get(prev).push(child);
      pred.get(child).push(prev);
    });
  });

  // ---------- Layers from levels ----------
  let layers = [];
  level.forEach((v,id)=> { (layers[v]||(layers[v]=[])).push(id); });

  // ---------- Barycenter ordering (forward + reverse, multiple sweeps) ----------
  const posIndex = new Map();
  const recomputePos = () => {
    posIndex.clear();
    layers.forEach((ids, L) => ids.forEach((id, i) => posIndex.set(id, i)));
  };
  recomputePos();

  const avgOf = (arr, map) => arr.length ? arr.reduce((a,b)=>a+(map.get(b)??0),0)/arr.length : -1e9;

  function sweepForward(){
    for (let L=1; L<layers.length; L++){
      layers[L].sort((a,b)=>{
        const aa = avgOf(pred.get(a)||[], posIndex);
        const bb = avgOf(pred.get(b)||[], posIndex);
        return aa - bb || a.localeCompare(b);
      });
    }
  }
  function sweepReverse(){
    for (let L=layers.length-2; L>=0; L--){
      layers[L].sort((a,b)=>{
        const aa = avgOf(succ.get(a)||[], posIndex);
        const bb = avgOf(succ.get(b)||[], posIndex);
        return aa - bb || a.localeCompare(b);
      });
    }
  }

  for (let i=0;i<4;i++){ // 4 sweeps: Fwd,Rev,Fwd,Rev
    sweepForward();  recomputePos();
    sweepReverse();  recomputePos();
  }

  // ---------- Scale (fit) & absolute positions ----------
  if (scale === 'fit') {
    const baseW = (layers.length + 1)*XSTEP0 + 2*PAD0;
    scale = Math.max(1.15, fitW / baseW);
  }
  const s     = +scale;
  const GW    = Math.round(GW0*s), GH = Math.round(GH0*s), PIN = Math.round(PIN0*s);
  const XSTEP = Math.round(XSTEP0*s), YSTEP = Math.round(YSTEP0*s), PAD = Math.round(PAD0*s);

  const absPos = new Map();
  layers.forEach((ids, lx)=>{
    ids.forEach((id, ly)=>{
      absPos.set(id, { x: PAD + lx*XSTEP, y: PAD + ly*YSTEP });
    });
  });

  const width  = (layers.length + 1)*XSTEP + 2*PAD;
  const height = Math.max(1, ...layers.map(a=>a.length))*YSTEP + 2*PAD + (caption ? Math.round(28*s) : 0);

  // ---------- Helpers ----------
  const inPinY = (y, n, k) => y + GH*((k+1)/(Math.max(1,n)+1));

  function drawGate(n){
    if (n.type === "WIRE") return ""; // invisible wire dummy
    const { x, y } = absPos.get(n.id);
    const nIns = (n.ins||[]).length || 1;
    const pins = Array.from({length:nIns},(_,k)=>{
      const yy = inPinY(y, nIns, k);
      return `<line x1="${x-PIN}" y1="${yy}" x2="${x}" y2="${yy}" />`;
    }).join("");

    if (n.type==="IN"){
      const w=Math.round(58*s), h=Math.round(26*s), r=Math.round(6*s);
      return `<rect x="${x}" y="${y}" rx="${r}" width="${w}" height="${h}" />
              <text x="${x+w/2}" y="${y+h/2+6}" text-anchor="middle" class="mono">${n.label||n.id}</text>`;
    }
    if (n.type==="NOT")  return pins + gateNOT(x, y, s);
    if (n.type==="AND")  return pins + gateAND(x, y, s);
    if (n.type==="OR")   return pins + gateOR(x, y, s);
    if (n.type==="XOR")  return pins + gateXOR(x, y, s);
    if (n.type==="NAND") return pins + gateAND(x, y, s) + bubble(x+GW+Math.round(8*s), y+GH/2, s);
    if (n.type==="NOR")  return pins + gateOR(x, y, s)  + bubble(x+GW+Math.round(8*s), y+GH/2, s);
    if (n.type==="XNOR") return pins + gateXOR(x, y, s) + bubble(x+GW+Math.round(8*s), y+GH/2, s);

    // fallback
    return pins + `<rect x="${x}" y="${y}" rx="${Math.round(10*s)}" width="${GW}" height="${GH}" />
                   <text x="${x+GW/2}" y="${y+GH/2+5}" text-anchor="middle" class="mono">${n.type}</text>`;
  }

  // Orthogonal H-V-H with per-input tracks (no near-gate overlaps)
  function wiresTo(targetId){
    const t = nodes.get(targetId);
    const dst = absPos.get(targetId);
    const xLeft = dst.x, yTop = dst.y;
    const ins = (t.ins||[]);
    return ins.map((srcId, k)=>{
      const sPos = absPos.get(srcId) || { x: xLeft - XSTEP/2, y: yTop };
      const x1 = sPos.x + GW, y1 = sPos.y + GH/2;
      const x2 = xLeft,       y2 = inPinY(yTop, ins.length||1, k);
      const trackGap = Math.round(22*s);
      const bendX = x2 - Math.round(GW/4) - (k+1)*trackGap; // unique vertical track per input
      return `M${x1},${y1} H${bendX} V${y2} H${x2}`;
    }).join(" ");
  }

  // Draw wires for ALL nodes that have inputs (includes WIRE nodes)
  const wiresSVG = Array.from(nodes.values())
    .filter(n => (n.ins||[]).length)
    .map(n => `<path d="${wiresTo(n.id)}" />`).join("");

  const gatesSVG = Array.from(nodes.values()).map(drawGate).join("");

  const outPos = absPos.get(net.output) || { x: width - 80, y: height/2 };
  const captionSVG = caption ? `<text x="${PAD}" y="${height - Math.round(10*s)}" class="mono">F = ${caption}</text>` : "";

  return `<svg viewBox="0 0 ${width} ${height}" width="100%">
    <g class="wires" fill="none" stroke="currentColor"
       stroke-width="${Math.max(2.6, 2.6*s)}" stroke-linecap="round" stroke-linejoin="round"
       vector-effect="non-scaling-stroke">
      ${wiresSVG}
    </g>
    <g class="gates" fill="none" stroke="currentColor"
       stroke-width="${Math.max(2.6, 2.6*s)}" stroke-linecap="round" stroke-linejoin="round"
       vector-effect="non-scaling-stroke">
      ${gatesSVG}
    </g>
    <g class="labels" fill="currentColor">${captionSVG}
      <text x="${outPos.x + Math.round(90*s)}" y="${outPos.y + Math.round(24*s)}" class="mono">F</text>
    </g>
  </svg>`;
}












  

  async function drawCircuit(style){
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) { alert("Enter an expression"); return; }
    resEl.textContent = `Generating ${style.toUpperCase()} circuit…`;
    ttCard.style.display="none"; ttEl.innerHTML="";

    const r = await fetch(API + "/api/ba/netlist", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ expr: text, vars, style })
    });
    const j = await r.json();
    if (!j.ok) { resEl.innerHTML = `<span class="muted">Error: ${j.error}</span>`; return; }
    const fitWidth = resEl.clientWidth ? (resEl.clientWidth - 24) : undefined;
    //resEl.innerHTML = renderCircuitSVG(j, { caption: exprEl.value.trim(), scale: 'fit', fitWidth });
    resEl.innerHTML = renderCircuitSVG(j, {
  caption: exprEl.value.trim(),
  scale: 'fit',
  fitWidth: resEl.clientWidth - 24   // or any target width you prefer
});

  }

  $("#btnCircuit").addEventListener("click", () => drawCircuit("mixed"));
  $("#btnCircuitNAND").addEventListener("click", () => drawCircuit("nand"));
  $("#btnCircuitNOR").addEventListener("click", () => drawCircuit("nor"));

  /* ---------- KMAP Pairings & Solution (big SVG) ---------- */
  async function showKmapGroups() {
    const text = exprEl.value.trim();
    if (!text) { alert("Type a kmap command or an expression."); return; }

    let vars, mode="ones", minForGrid, body;

    const km = parseKmapCommand(text);
    if (km) {
      vars = km.vars;
      if (km.expr) {
        const r1 = await fetch(API + "/api/ba/simplify", {
          method:"POST", headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
        });
        const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
        minForGrid = j1.minterms;
        mode = "ones";
        body = { vars, minterms: minForGrid, full:true, mode };
      } else if (km.mode === "zeros") {
        vars = km.vars; mode = "zeros"; minForGrid = km.minterms;
        body = { vars, maxterms: km.maxterms, full:true, mode };
      } else {
        vars = km.vars; mode = "ones"; minForGrid = km.minterms;
        body = { vars, minterms: minForGrid, full:true, mode };
      }
    } else {
      // plain expression: compute minterms
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars: varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
      vars = j1.vars; minForGrid = j1.minterms; mode = "ones";
      body = { vars, minterms: minForGrid, full:true, mode };
    }

    const r2 = await fetch(API + "/api/ba/kmap", {
      method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body)
    });
    const j2 = await r2.json(); if (!j2.ok) { resEl.innerHTML = `<span class="muted">Error: ${j2.error}</span>`; return; }

    resEl.innerHTML =
      renderKmapSVG(vars, minForGrid,
        j2.allGroups.filter(g => g.hr*g.wr === 2),
        mode === "zeros" ? "All pairings (size 2) · POS (0-groups)" : "All pairings (size 2) · SOP",
        { mode, scale: 2.0 }) +
      renderKmapSVG(vars, minForGrid, j2.solutionGroups,
        mode === "zeros" ? `Solution (POS): ${j2.simplified}` : `Solution (SOP): ${j2.simplified}`,
        { mode, scale: 2.2 });
  }

  $("#btnKmapGroups").addEventListener("click", () => {
    ttCard.style.display="none"; ttEl.innerHTML="";
    resEl.textContent = "Analyzing K-map…";
    showKmapGroups().catch(e => resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`);
  });
</script>
</body>
</html>
