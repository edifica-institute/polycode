<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none }
    a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:auto; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
    .grid > .card.wide { grid-column: 1 / -1; }

    /* Ensure big SVGs aren’t clamped */
    #result svg { max-height: none !important; width: 100%; height: auto; }

    /* More room when wide */
    aside.card.wide { padding-block: 24px; }
  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses. Implicit AND allowed, e.g., <b>AB + A~C</b>. K-map commands: <b>kmap A,B,C : Σm(1,3,5)</b> or <b>kmap A,B : ΠM(0,2)</b>, or <b>kmap A,B,C : AB + A'C</b>.</p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>
          <button class="btn secondary" id="btnCircuit">Circuit</button>
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>
          <button class="btn secondary" id="btnKmapGroups">K-map Pairings &amp; Solution</button>
          <button class="btn secondary" id="btnClear">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>

<script type="module">
  const API = "https://polycode-ba.onrender.com";
  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");
  const gray = n => n ^ (n >> 1);

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = ""; varsEl.value = "";
    resEl.innerHTML = ""; ttCard.style.display = "none"; ttEl.innerHTML = "";
  });

  /* ---------- KMAP PARSING (Σ / Π / expr) ---------- */
  function parseKmapCommand(s){
    const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
    if (!mHdr) return null;

    const vars = mHdr[1].split(",").map(x=>x.trim());
    let rhs = mHdr[2].trim();

    // Optional don't-cares: ; d(…)
    let dontCares = [];
    const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
    if (mDC) { dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite); rhs = rhs.slice(0, mDC.index).trim(); }

    const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
    const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
    const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

    if (reSigma.test(rhs)) {
      const mm = reSigma.exec(rhs);
      const minterms = parseList(mm[1]);
      return { vars, mode:"ones", minterms, dontCares };
    }
    if (rePi.test(rhs)) {
      const mm = rePi.exec(rhs);
      const maxterms = parseList(mm[1]);
      const n = vars.length, U = Array.from({length:1<<n},(_,i)=>i);
      const bad = new Set([...maxterms, ...dontCares]);
      const minterms = U.filter(i => !bad.has(i)); // for grid display
      return { vars, mode:"zeros", maxterms, minterms, dontCares };
    }
    if (/^[0-9,\s]+$/.test(rhs)) {
      const minterms = parseList(rhs);
      return { vars, mode:"ones", minterms, dontCares };
    }
    return { vars, expr: rhs, dontCares };
  }

  /* ---------- BASIC GRID (compact HTML table) ---------- */
  function renderKmapTable(vars, minterms){
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;

    const grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
    for (let i=0; i<(1<<n); i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const rowLabels = Array.from({length:rows}, (_,r)=>(gray(r)>>>0).toString(2).padStart(rbits,'0'));
    const colLabels = Array.from({length:cols}, (_,c)=>(gray(c)>>>0).toString(2).padStart(cbits,'0'));

    const head =
      `<tr><th>${vars.slice(0,rbits).join("") || "&nbsp;"}</th>` +
      colLabels.map(l=>`<th>${vars.slice(rbits).join("")? vars.slice(rbits).join("")+"="+l : l}</th>`).join("") + `</tr>`;
    const body = grid.map((row,r) =>
      `<tr><th>${vars.slice(0,rbits).join("")? vars.slice(0,rbits).join("")+"="+rowLabels[r] : rowLabels[r]}</th>` +
      row.map(v=>`<td>${v}</td>`).join("") + `</tr>`
    ).join("");

    resEl.innerHTML = `
      <div class="mono">K-map (${n} vars): ${vars.join(", ")}</div>
      <table style="margin-top:8px"><thead>${head}</thead><tbody>${body}</tbody></table>
      <div class="muted" style="margin-top:8px">Tip: groups are powers of 2; wrap edges.</div>
    `;
  }

  /* ---------- BIG SVG KMAP WITH GROUPS (bridges + numbering) ---------- */
  function renderKmapSVG(vars, minterms, groups = [], title = "K-map", opts = {}) {
    const mode   = opts.mode ?? "ones";      // "ones" (SOP) | "zeros" (POS)
    const scale  = opts.scale ?? 2.0;
    const cellW  = Math.round(42 * scale);
    const cellH  = Math.round(30 * scale);
    const pad    = Math.round(24 * scale);
    const font14 = Math.round(14 * scale);
    const font12 = Math.round(12 * scale);

    // dims
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1<<rbits, cols = 1<<cbits;
    const gray = x => x ^ (x>>1);

    // grid (1 = minterm)
    const grid = Array.from({length:rows},()=>Array(cols).fill(0));
    for (let i=0;i<(1<<n);i++){
      const r = gray(i>>cbits)&(rows-1);
      const c = gray(i&((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const W = pad*2 + cols*cellW + 100, H = pad*2 + rows*cellH + 40;
    const X0 = pad, Y0 = pad, X1 = pad + cols*cellW, Y1 = pad + rows*cellH;

    // split a toroidal rect into up to 4 screen rects
    function splitSegments(g){
      const r0 = ((g.r % rows) + rows) % rows;
      const c0 = ((g.c % cols) + cols) % cols;
      const rh1 = Math.min(g.hr, rows - r0);
      const cw1 = Math.min(g.wr, cols - c0);

      const segs = [{ r:r0, c:c0, hr:rh1, wr:cw1 }];
      if (g.wr > cw1) segs.push({ r:r0, c:0, hr:rh1, wr:g.wr - cw1 });
      if (g.hr > rh1){
        segs.push({ r:0, c:c0, hr:g.hr - rh1, wr:cw1 });
        if (g.wr > cw1) segs.push({ r:0, c:0, hr:g.hr - rh1, wr:g.wr - cw1 });
      }
      return { segs, r0, c0, wrapH: (c0 + g.wr) > cols, wrapV: (r0 + g.hr) > rows };
    }

    // palette & styles
    const palette = [
      "#FF6B6B","#4DD0E1","#FFD166","#A78BFA",
      "#26A69A","#F48FB1","#64B5F6","#FF8A65",
      "#81C784","#E57373"
    ];
    const dashAttr = (mode === "zeros")
      ? ` stroke-dasharray="${Math.round(6*scale)} ${Math.round(4*scale)}"`
      : "";

    // cells
    const cells = grid.map((row,ri)=>
      row.map((v,ci)=>{
        const x = X0 + ci*cellW, y = Y0 + ri*cellH;
        return `<rect x="${x}" y="${y}" width="${cellW}" height="${cellH}" fill="none" stroke="currentColor" opacity="0.35"/>
                <text x="${x+cellW/2}" y="${y+cellH/2+font14/3}" text-anchor="middle"
                      class="mono" font-size="${font14}" fill="currentColor">${v}</text>`;
      }).join("")
    ).join("");

    // labels
    const colLbl = Array.from({length:cols},(_,c)=> (gray(c)>>>0).toString(2).padStart(cbits,'0'))
      .map((l,i)=>`<text x="${X0 + i*cellW + cellW/2}" y="${Y0-6}" text-anchor="middle"
                    class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");
    const rowLbl = Array.from({length:rows},(_,r)=> (gray(r)>>>0).toString(2).padStart(rbits,'0'))
      .map((l,i)=>`<text x="${X0-6}" y="${Y0 + i*cellH + cellH/2+font12/3}"
                    text-anchor="end" class="mono" font-size="${font12}" fill="currentColor">${l||""}</text>`).join("");

    // groups: outlines + numbers + wrap bridges
    let rects = "", labels = "", bridges = "";
    groups.forEach((g,gi)=>{
      const color = palette[gi % palette.length];
      const { segs, r0, c0, wrapH, wrapV } = splitSegments(g);

      segs.forEach(s=>{
        const x = X0 + s.c*cellW, y = Y0 + s.r*cellH;
        const w = s.wr*cellW,    h = s.hr*cellH;
        rects += `<rect x="${x+2}" y="${y+2}" width="${w-4}" height="${h-4}"
                         rx="${Math.round(8*scale)}" fill="none"
                         stroke="${color}" stroke-width="2"${dashAttr}
                         vector-effect="non-scaling-stroke"/>`;
        labels += `<text x="${x + w/2}" y="${y + h/2 + font12/3}" text-anchor="middle"
                         class="mono" font-size="${font12}" fill="${color}">${gi+1}</text>`;
      });

      if (wrapH) {
        const yMid = Y0 + ((r0 + g.hr/2) % rows) * cellH;
        const L = Math.round(10 * scale);
        bridges += `<path d="M${X0-L},${yMid} H${X0}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
        bridges += `<path d="M${X1},${yMid} H${X1+L}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
      }
      if (wrapV) {
        const xMid = X0 + ((c0 + g.wr/2) % cols) * cellW;
        const L = Math.round(10 * scale);
        bridges += `<path d="M${xMid},${Y0-L} V${Y0}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
        bridges += `<path d="M${xMid},${Y1} V${Y1+L}" stroke="${color}" stroke-width="2" fill="none"${dashAttr} vector-effect="non-scaling-stroke"/>`;
      }
    });

    const subtitle = (mode === "zeros")
      ? `<div class="muted mono">Mode: POS — groups on 0-cells (dashed). Same color/number = one wrap-group.</div>`
      : `<div class="muted mono">Mode: SOP — groups on 1-cells. Same color/number = one wrap-group.</div>`;

    return `<div class="mono" style="margin:.5rem 0 .25rem">${title}</div>
            ${subtitle}
            <svg viewBox="0 0 ${W} ${H}" width="100%">
              <g fill="none" stroke="currentColor">${cells}</g>
              <g fill="currentColor">${colLbl}${rowLbl}</g>
              <g fill="none">${rects}</g>
              <g>${labels}</g>
              <g fill="none">${bridges}</g>
            </svg>`;
  }

  /* ---------- K-map de-dup helpers (client-side) ---------- */
  function dimsFromVars(vars){
    const n = vars.length, rbits = Math.floor(n/2);
    return { rows: 1<<rbits, cols: 1<<(n-rbits) };
  }
  function rectCellKey(g, vars){
    const { rows, cols } = dimsFromVars(vars);
    const cells = [];
    for (let i=0;i<g.hr;i++){
      for (let j=0;j<g.wr;j++){
        cells.push(`${(g.r+i)%rows},${(g.c+j)%cols}`);
      }
    }
    cells.sort();
    return cells.join("|");
  }
  function dedupeRectsClient(rects, vars){
    const seen = new Set(), out = [];
    for (const r of rects){
      const k = rectCellKey(r, vars);
      if (seen.has(k)) continue;
      seen.add(k); out.push(r);
    }
    return out;
  }

  const resultCard = document.querySelector("aside.card");

  async function drawCircuit(style){
    const text = exprEl.value.trim();
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    if (!text) { alert("Enter an expression"); return; }

    resEl.textContent = `Generating ${style.toUpperCase()} circuit…`;
    ttCard.style.display="none"; ttEl.innerHTML="";

    resultCard?.classList.add("wide");

    const r = await fetch(API + "/api/ba/netlist", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ expr: text, vars, style })
    });
    const j = await r.json();
    if (!j.ok) { resEl.innerHTML = `<span class="muted">Error: ${j.error}</span>`; return; }

    requestAnimationFrame(() => {
      const fitWidth = resultCard.getBoundingClientRect().width - 32;
      resEl.innerHTML = renderCircuitSVG(j, {
        caption: exprEl.value.trim(),
        scale: 'fit',
        fitWidth,
        zoom: 2.2
      });
    });
  }

  $("#btnCircuit").addEventListener("click", () => drawCircuit("mixed"));
  $("#btnCircuitNAND").addEventListener("click", () => drawCircuit("nand"));
  $("#btnCircuitNOR").addEventListener("click", () => drawCircuit("nor"));

  /* ---------- SIMPLIFY button ---------- */
  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    // K-map command?
    const km = parseKmapCommand(text);
    if (km) {
      ttCard.style.display = "none"; ttEl.innerHTML = "";
      resEl.textContent = "Building K-map…";

      try {
        // If expression was provided after `kmap ...`, compute minterms for grid display
        let displayMins = km.minterms;
        if (km.expr) {
          const r1 = await fetch(API + "/api/ba/simplify", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
          });
          const j1 = await r1.json();
          if (!j1.ok) throw new Error(j1.error || "simplify error");
          displayMins = j1.minterms;
        }

        // payload for kmap
        const body =
          km.mode === "zeros"
            ? { vars: km.vars, mode: "zeros", maxterms: km.maxterms, full: true }
            : { vars: km.vars, mode: "ones",  minterms: displayMins, full: true };

        const r = await fetch(API + "/api/ba/kmap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const j = await r.json();
        if (!j.ok) throw new Error(j.error || "kmap error");

        // DE-DUPE solution groups before drawing
        const solGroups = dedupeRectsClient(j.solutionGroups || [], km.vars);

        resEl.innerHTML = renderKmapSVG(
          km.vars,
          displayMins,
          solGroups,
          j.mode === "zeros"
            ? `Solution (POS): ${j.simplified}`
            : `Solution (SOP): ${j.simplified}`,
          { mode: j.mode, scale: 2.2 }
        );
      } catch (e) {
        resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      }
      return;
    }

    // Otherwise, normal simplify flow
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else {
        ttCard.style.display="none"; ttEl.innerHTML="";
      }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });

  /* ---------- KMAP Pairings & Solution (big SVG) ---------- */
  async function showKmapGroups() {
    const text = exprEl.value.trim();
    if (!text) { alert("Type a kmap command or an expression."); return; }

    let vars, mode = "ones", minterms, maxterms;
    const km = parseKmapCommand(text);

    if (km) {
      vars = km.vars;
      mode = km.mode;                // "ones" | "zeros"
      if (km.expr) {
        const r1 = await fetch(API + "/api/ba/simplify", {
          method:"POST", headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
        });
        const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
        minterms = j1.minterms;
      } else {
        minterms = km.minterms;
        maxterms = km.maxterms;
      }
    } else {
      // plain expression: compute minterms; SOP by default
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars: varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
      vars = j1.vars; minterms = j1.minterms;
    }

    const body = (mode === "zeros")
      ? { vars, mode:"zeros", maxterms: maxterms ?? [], full: true }
      : { vars, mode:"ones",  minterms: minterms ?? [], full: true };

    const r2 = await fetch(API + "/api/ba/kmap", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    const j2 = await r2.json();
    if (!j2.ok) { resEl.innerHTML = `<span class="muted">Error: ${j2.error}</span>`; return; }

    // DE-DUPE both pairings and solution groups
    const pairsRaw = (j2.allGroups || []).filter(g => g.hr*g.wr === 2);
    const pairs = dedupeRectsClient(pairsRaw, vars);
    const solution = dedupeRectsClient(j2.solutionGroups || [], vars);

    resEl.innerHTML =
      renderKmapSVG(vars, minterms ?? [], pairs, "All pairings (size 2)", { mode, scale: 2.0 }) +
      renderKmapSVG(vars, minterms ?? [], solution,
        mode === "zeros" ? `Solution (POS): ${j2.simplified}` : `Solution (SOP): ${j2.simplified}`,
        { mode, scale: 2.2 });
  }

  $("#btnKmapGroups").addEventListener("click", () => {
    ttCard.style.display="none"; ttEl.innerHTML="";
    resEl.textContent = "Analyzing K-map…";
    showKmapGroups().catch(e => resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`);
  });
</script>
</body>
</html>
