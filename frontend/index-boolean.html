<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>polycode | Boolean Algebra</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <link rel="icon" href="./assets/logo.png" />
  <style>
    :root{ --bg:#0b0f13; --bg2:#141922; --panel:#1e2024; --text:#e9edf3; --muted:#aeb5bd; --link:#9ecbff; --brand:#2e5bea; --border:#2b2f34; }
    *{ box-sizing:border-box }
    body{ margin:0; background:linear-gradient(180deg,var(--bg),var(--bg2)); color:var(--text); font-family:system-ui,Roboto,Ubuntu,sans-serif; }
    a{ color:var(--link); text-decoration:none }
    a:hover{ text-decoration:underline }
    header{ display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#1a1c1f; border-bottom:1px solid var(--border) }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand img{ width:26px; height:26px; border-radius:6px }
    main{ max-width:1100px; margin:0 auto; padding:18px }
    .grid{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:980px){ .grid{ grid-template-columns:1.1fr .9fr; } }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 16px 50px rgba(0,0,0,.28) }
    .card h2{ margin:0 0 10px; font-size:20px }
    textarea{ width:100%; min-height:90px; background:#141922; color:var(--text); border:1px solid var(--border); border-radius:10px; padding:10px; outline:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 }
    .btn{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:var(--brand); color:#fff; font-weight:600; cursor:pointer }
    .btn.secondary{ background:#24272d; color:#d5dbe4 }
    .mono{ font-family:ui-monospace,Menlo,Consolas,monospace; }
    table{ width:100%; border-collapse:collapse; font-size:14px }
    th,td{ border:1px solid var(--border); padding:6px 8px; text-align:center }
    th{ background:#1a1c1f }
    .muted{ color:#aeb5bd }
  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="./assets/logo.png" alt="polycode"/><div>PolyCode — Boolean Algebra</div></div>
    <nav><a href="./index.html">Home</a></nav>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Expression</h2>
        <p class="muted mono">Ops: + (OR), ·/*/& (AND), ~(NOT), ^ (XOR), parentheses. Implicit AND allowed, e.g., <b>AB + A~C</b>.</p>
        <textarea id="expr" placeholder="Example: A·B + ¬A·C"></textarea>
        <div class="row">
          <label class="muted"><input type="checkbox" id="includeTable"> Show truth table</label>
          <span class="muted">Vars (optional, comma):</span>
          <input id="vars" placeholder="A,B,C" style="padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#141922;color:var(--text)">
          <button class="btn" id="btnSimplify">Simplify</button>
          <button class="btn secondary" id="btnCircuit">Circuit</button>
          <button class="btn secondary" id="btnCircuitNAND">NAND-only</button>
          <button class="btn secondary" id="btnCircuitNOR">NOR-only</button>
<button class="btn secondary" id="btnKmapGroups">K-map Pairings & Solution</button>

          <button class="btn secondary" id="btnClear">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h2>Result</h2>
        <div id="result" class="mono"></div>
      </aside>
    </div>

    <section class="card" id="ttCard" style="display:none">
      <h2>Truth Table</h2>
      <div id="tt"></div>
    </section>
  </main>



<script type="module">
  const API = "https://polycode-ba.onrender.com";

  const $ = s => document.querySelector(s);
  const exprEl = $("#expr"), varsEl = $("#vars"), resEl = $("#result");
  const includeTableEl = $("#includeTable"), ttCard = $("#ttCard"), ttEl = $("#tt");

  $("#btnClear").addEventListener("click", () => {
    exprEl.value = "";
    varsEl.value = "";
    resEl.innerHTML = "";
    ttCard.style.display = "none";
    ttEl.innerHTML = "";
  });

  const gray = n => n ^ (n >> 1);

function parseKmapCommand(s){
  // kmap <vars> [:|=] < list | Σm(...) | ΠM(...) | boolean expr > [ ; d(...) ]
  const mHdr = /^kmap\s+([A-Za-z0-9_]+(?:\s*,\s*[A-Za-z0-9_]+){1,3})\s*[:=]\s*(.+)$/i.exec(s.trim());
  if (!mHdr) return null;

  const vars = mHdr[1].split(",").map(x=>x.trim());
  let rhs = mHdr[2].trim();

  // Optional don't-cares at end: ; d(...)
  let dontCares = [];
  const mDC = /(?:[,;]\s*d\s*\(\s*([0-9,\s]+)\s*\)\s*)$/i.exec(rhs);
  if (mDC) { dontCares = mDC[1].split(",").map(x=>+x.trim()).filter(Number.isFinite); rhs = rhs.slice(0, mDC.index).trim(); }

  const parseList = str => str.split(",").map(x=>+x.trim()).filter(Number.isFinite);
  const reSigma = /^(?:Σ|sigma|s)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;
  const rePi    = /^(?:Π|pi|prod|p)\s*m?\s*\(\s*([0-9,\s]+)\s*\)$/i;

  // Σm(...)
  if (reSigma.test(rhs)) {
    const mm = reSigma.exec(rhs);
    const minterms = parseList(mm[1]);
    return { vars, mode: "ones", minterms, dontCares };
  }

  // ΠM(...): keep maxterms for grouping (zeros), but also compute minterms for display.
  if (rePi.test(rhs)) {
    const mm = rePi.exec(rhs);
    const maxterms = parseList(mm[1]);
    const n = vars.length;
    const universe = Array.from({length:1<<n}, (_,i)=>i);
    const bad = new Set([...maxterms, ...dontCares]);
    const minterms = universe.filter(i => !bad.has(i)); // for grid display
    return { vars, mode: "zeros", maxterms, minterms, dontCares };
  }

  // Plain list 1,2,3 (assume Σ by default)
  if (/^[0-9,\s]+$/.test(rhs)) {
    const minterms = parseList(rhs);
    return { vars, mode: "ones", minterms, dontCares };
  }

  // Otherwise treat as Boolean expression (AB + A'C)
  return { vars, expr: rhs, dontCares };
}




  function renderKmap(vars, minterms){
    const n = vars.length;
    const rbits = Math.floor(n/2), cbits = n - rbits;
    const rows = 1 << rbits, cols = 1 << cbits;

    const grid = Array.from({length:rows}, ()=>Array(cols).fill(0));
    for (let i=0; i < (1<<n); i++){
      const r = gray(i >> cbits) & (rows - 1);
      const c = gray(i & ((1<<cbits)-1));
      grid[r][c] = minterms.includes(i) ? 1 : 0;
    }

    const rowLabels = Array.from({length:rows}, (_,r)=> (gray(r) >>> 0).toString(2).padStart(rbits,'0'));
    const colLabels = Array.from({length:cols}, (_,c)=> (gray(c) >>> 0).toString(2).padStart(cbits,'0'));

    const head =
      `<tr><th>${vars.slice(0,rbits).join("") || "&nbsp;"}</th>` +
      colLabels.map(l=>`<th>${vars.slice(rbits).join("")? vars.slice(rbits).join("")+"="+l : l}</th>`).join("") +
      `</tr>`;
    const body = grid.map((row,r) =>
      `<tr><th>${vars.slice(0,rbits).join("")? vars.slice(0,rbits).join("")+"="+rowLabels[r] : rowLabels[r]}</th>` +
      row.map(v=>`<td>${v}</td>`).join("") + `</tr>`
    ).join("");

    resEl.innerHTML = `
      <div class="mono">K-map (${n} vars): ${vars.join(", ")}</div>
      <div class="muted mono">Minterms: [${minterms.join(", ")}]</div>
      <table style="width:auto;border-collapse:collapse;margin-top:8px;font-size:14px">
        <thead>${head}</thead>
        <tbody>${body}</tbody>
      </table>
      <div class="muted" style="margin-top:8px">Tip: groups are powers of 2; wrap edges when grouping.</div>
    `;
  }

  $("#btnSimplify").addEventListener("click", async () => {
    const text = exprEl.value.trim();
    if (!text) { alert("Enter an expression or a kmap command"); return; }

    // --- KMAP COMMAND? ---
// KMAP COMMAND
const km = parseKmapCommand(text);
if (km) {
  ttCard.style.display = "none"; ttEl.innerHTML = "";
  resEl.textContent = "Building K-map…";
  try {
    // If user typed an expression after "kmap ...", get minterms for display
    let displayMins = km.minterms;
    if (km.expr) {
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error || "simplify error");
      displayMins = j1.minterms;
    }

    // Ask backend for groups in the right mode (ones or zeros)
    const body = (km.mode === "zeros")
      ? { vars: km.vars, maxterms: km.maxterms, full: true, mode: "zeros" }
      : { vars: km.vars, minterms: displayMins, full: true, mode: "ones" };

    const r = await fetch(API + "/api/ba/kmap", {
      method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body)
    });
    const j = await r.json(); if (!j.ok) throw new Error(j.error||"kmap error");

    // Render grid with true function values (1s = minterms), but overlay rectangles from j.solutionGroups
    renderKmap(km.vars, displayMins);             // your existing grid (shows 1/0)
    // If you have an SVG renderer that accepts groups, call it here instead:
    // resEl.innerHTML = renderKmapSVG(km.vars, displayMins, j.solutionGroups,
    //                                 j.mode === "zeros" ? `Solution (POS): ${j.simplified}` : `Solution (SOP): ${j.simplified}`);

  } catch (e) {
    resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
  }
  return;
}

    // --- OTHERWISE: normal simplify flow ---
    const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()).filter(Boolean) : undefined;
    resEl.textContent = "Working…";
    try{
      const r = await fetch(API + "/api/ba/simplify", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: text, vars, includeTable: includeTableEl.checked })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.error||"error");
      const { vars:V, minterms, maxterms, sop, pos, simplifiedSOP } = j;
      resEl.innerHTML = `
        <div>Vars: ${V.join(", ")}</div>
        <div>Σ m: ${sop}</div>
        <div>Π M: ${pos}</div>
        <div>Simplified (SOP): <b>${simplifiedSOP}</b></div>
        <div class="muted">Minterms: [${minterms.join(", ")}] — Maxterms: [${maxterms.join(", ")}]</div>
      `;
      if (includeTableEl.checked && j.table){
        const rows = j.table;
        const cols = V.map(v=>`<th>${v}</th>`).join("") + "<th>f</th>";
        const trs = rows.map(r=>{
          const tds = V.map(v=>`<td>${r.env[v]?1:0}</td>`).join("") + `<td>${r.out}</td>`;
          return `<tr>${tds}</tr>`;
        }).join("");
        ttEl.innerHTML = `<table><thead><tr>${cols}</tr></thead><tbody>${trs}</tbody></table>`;
        ttCard.style.display="";
      } else {
        ttCard.style.display="none"; ttEl.innerHTML="";
      }
    }catch(e){
      resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`;
      ttCard.style.display="none"; ttEl.innerHTML="";
    }
  });



// dumb layout: layer by distance from inputs
function renderCircuitSVG(net, opts = {}) {
  const caption = opts.caption ?? "";     // e.g., "F = ABC + AB"
  const scale   = opts.scale   ?? 1.25;   // make it larger
  const GW = Math.round(72 * scale);      // gate width
  const GH = Math.round(46 * scale);      // gate height
  const PIN = Math.round(10 * scale);     // input pin length

  // --- layout (longest path levels) ---
  const nodes = new Map();
  for (const g of net.gates) nodes.set(g.id, {...g});
  for (const i of net.inputs) nodes.set(i.id, { id:i.id, type:"IN", ins:[], label:i.label });
  nodes.set(net.output, nodes.get(net.output) || { id: net.output, type:"OUT", ins:[] });

  const level = new Map();
  const lev = (id) => {
    if (level.has(id)) return level.get(id);
    const n = nodes.get(id) || {ins:[]};
    const v = (n.type === "IN" || id === "VCC_1" || id === "GND_0")
      ? 0
      : Math.max(0, ...(n.ins || []).map(lev)) + 1;
    level.set(id, v); return v;
  };
  [...nodes.keys()].forEach(lev);
  const layers = [];
  for (const [id,v] of level.entries()) (layers[v] || (layers[v] = [])).push(id);

  const XSTEP = Math.round(180 * scale);
  const YSTEP = Math.round(100 * scale);
  const PAD   = Math.round(28  * scale);

  const width  = (layers.length + 1) * XSTEP + PAD * 2;
  const height = Math.max(1, ...layers.map(a => a.length)) * YSTEP + PAD * 2 + (caption ? 32 : 0);

  const pos = new Map();
  layers.forEach((ids, x) =>
    ids.forEach((id, y) => pos.set(id, { x: PAD + x * XSTEP, y: PAD + y * YSTEP }))
  );

  // ---- helpers: input anchors for k of n ----
  const inY = (y, n, k) => y + GH * ((k + 1) / (n + 1));
  const outXY = (x, y) => ({ x: x + GW, y: y + GH / 2 });

  // ---- ANSI/IEC gate icons ----
  const bubble = (x, y, r = Math.round(6 * scale)) =>
    `<circle cx="${x}" cy="${y}" r="${r}" stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>`;

  // AND (D-shape)
  const pathAND = (x, y) => {
    const r = GH / 2, xr = x + GW - r, xb = x + GW;
    return `<path d="M${x},${y} H${xr} A${r},${r} 0 0 1 ${xr},${y+GH} H${x} Z"
             fill="none" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
  };

  // OR (curved)
  const pathOR = (x, y) => {
    const xIn = x + Math.round(14*scale), xOut = x + GW - Math.round(10*scale);
    const xm  = x + GW - Math.round(22*scale);
    const b   = y + GH;
    return `<path d="M${xIn},${y}
                     C ${xm-22},${y} ${xm},${y+GH/2} ${xOut},${y+GH/2}
                     C ${xm},${y+GH/2} ${xm-22},${b} ${xIn},${b}
                     C ${x+6},${b-10} ${x+6},${y+10} ${xIn},${y}"
             fill="none" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
  };

  // XOR = OR + offset input curve
  const pathXOR = (x, y) => {
    const or = pathOR(x, y);
    const xIn = x + Math.round(8*scale);
    const xm  = x + GW - Math.round(22*scale);
    const b   = y + GH;
    const extra = `<path d="M${xIn},${y}
                           C ${xm-22},${y} ${xm},${y+GH/2} ${xIn},${b}"
                     fill="none" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
    return or + extra;
  };

  // NOT (triangle + bubble)
  const pathNOT = (x, y) => {
    const tri = `<path d="M${x},${y} L${x},${y+GH} L${x+GW-12},${y+GH/2} Z"
                  fill="none" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
    const b = bubble(x + GW - 4, y + GH/2);
    return tri + b;
  };

  function inputPins(x, y, n) {
    let s = "";
    for (let k = 0; k < n; k++) {
      const yy = inY(y, n, k);
      s += `<line x1="${x-PIN}" y1="${yy}" x2="${x}" y2="${yy}" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
    }
    return s;
  }

  function gateShape(g) {
    const { x, y } = pos.get(g.id);
    const n = (g.ins || []).length || 1;
    const out = outXY(x, y);

    if (g.type === "IN") {
      return `<rect x="${x}" y="${y}" width="${Math.round(58*scale)}" height="${Math.round(26*scale)}" rx="${Math.round(6*scale)}"
                    stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>` +
             `<text x="${x+Math.round(29*scale)}" y="${y+Math.round(18*scale)}" text-anchor="middle"
                    fill="currentColor" class="mono">${g.label||g.id}</text>`;
    }
    if (g.type === "NOT") return inputPins(x, y, 1) + pathNOT(x, y);

    if (g.type === "AND") return inputPins(x, y, n) + pathAND(x, y);
    if (g.type === "OR")  return inputPins(x, y, n) + pathOR(x, y);
    if (g.type === "XOR") return inputPins(x, y, n) + pathXOR(x, y);

    if (g.type === "NAND") return inputPins(x, y, n) + pathAND(x, y) + bubble(out.x + Math.round(8*scale), out.y);
    if (g.type === "NOR")  return inputPins(x, y, n) + pathOR(x, y)  + bubble(out.x + Math.round(8*scale), out.y);
    if (g.type === "XNOR") return inputPins(x, y, n) + pathXOR(x, y) + bubble(out.x + Math.round(8*scale), out.y);

    // Fallback
    return inputPins(x, y, n) +
           `<rect x="${x}" y="${y}" width="${GW}" height="${GH}" rx="${Math.round(10*scale)}"
                  stroke="currentColor" fill="none" vector-effect="non-scaling-stroke"/>` +
           `<text x="${x+GW/2}" y="${y+GH/2+5}" text-anchor="middle" fill="currentColor" class="mono">${g.type}</text>`;
  }

  // --- wires (spread to distinct input anchors) ---
  function wires(g) {
    const { x, y } = pos.get(g.id);
    const ins = g.ins || [];
    return ins.map((src, k) => {
      const srcPos = pos.get(src) || { x: x - XSTEP/2, y };
      const x1 = srcPos.x + GW, y1 = srcPos.y + GH/2;
      const x2 = x,             y2 = inY(y, ins.length || 1, k);
      const mx = (x1 + x2) / 2;
      return `<path d="M${x1},${y1} C ${mx},${y1} ${mx},${y2} ${x2},${y2}"
                fill="none" stroke="currentColor" vector-effect="non-scaling-stroke"/>`;
    }).join("");
  }

  const wiresSVG = net.gates.map(g => wires(g)).join("");
  const gatesSVG = [...nodes.values()].map(g => gateShape(g)).join("");
  const outPos = pos.get(net.output) || { x: width - 80, y: height / 2 };

  const captionSVG = caption
    ? `<text x="${PAD}" y="${height - Math.round(10*scale)}" class="mono"
              fill="currentColor">F = ${caption}</text>`
    : "";

  return `<svg viewBox="0 0 ${width} ${height}" width="100%" style="max-height:${Math.max(520, Math.round(520*scale))}px">
    <g class="wires" fill="none" stroke="currentColor" stroke-width="2">
      ${wiresSVG}
    </g>
    <g class="gates" stroke="currentColor" stroke-width="2" fill="none">
      ${gatesSVG}
    </g>
    <g class="label" fill="currentColor">${captionSVG}
      <text x="${outPos.x + Math.round(90*scale)}" y="${outPos.y + Math.round(24*scale)}" class="mono">F</text>
    </g>
  </svg>`;
}




  

async function drawCircuit(style){
  const text = exprEl.value.trim();
  const vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
  if (!text) { alert("Enter an expression"); return; }
  resEl.textContent = `Generating ${style.toUpperCase()} circuit…`;
  ttCard.style.display="none"; ttEl.innerHTML="";

  const r = await fetch(API + "/api/ba/netlist", {
    method:"POST", headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ expr: text, vars, style })
  });
  const j = await r.json();
  if (!j.ok) { resEl.innerHTML = `<span class="muted">Error: ${j.error}</span>`; return; }
  resEl.innerHTML = renderCircuitSVG(j, { caption: exprEl.value.trim(), scale: 1.35 }); // inject your SVG
}

document.getElementById("btnCircuit").addEventListener("click", () => drawCircuit("mixed"));
document.getElementById("btnCircuitNAND").addEventListener("click", () => drawCircuit("nand"));
document.getElementById("btnCircuitNOR").addEventListener("click", () => drawCircuit("nor"));






  
function renderKmapSVG(vars, minterms, groups=[], title="K-map"){
  const n = vars.length;
  const rbits = Math.floor(n/2), cbits = n - rbits;
  const rows = 1<<rbits, cols = 1<<cbits;
  const cellW=42, cellH=30, pad=24;
  const W = pad*2 + cols*cellW + 80, H = pad*2 + rows*cellH + 40;

  const gray = x => x ^ (x>>1);
  const gridVals = Array.from({length:rows},()=>Array(cols).fill(0));
  for (let i=0;i<(1<<n);i++){
    const r = gray(i>>cbits)&(rows-1);
    const c = gray(i&((1<<cbits)-1));
    gridVals[r][c] = minterms.includes(i) ? 1 : 0;
  }

  const rects = groups.map(g=>{
    const x = pad + g.c*cellW;
    const y = pad + g.r*cellH;
    const w = g.wr*cellW;
    const h = g.hr*cellH;
    return `<rect x="${x+2}" y="${y+2}" width="${w-4}" height="${h-4}" rx="8" fill="none" stroke="currentColor" stroke-width="2" opacity="0.9"/>`;
  }).join("");

  const cells = gridVals.map((row,ri)=>
    row.map((v,ci)=>{
      const x = pad + ci*cellW, y = pad + ri*cellH;
      return `<rect x="${x}" y="${y}" width="${cellW}" height="${cellH}" fill="none" stroke="currentColor" opacity="0.35"/>
              <text x="${x+cellW/2}" y="${y+cellH/2+5}" text-anchor="middle" class="mono" font-size="14">${v}</text>`;
    }).join("")
  ).join("");

  const colLbl = Array.from({length:cols},(_,c)=> (gray(c)>>>0).toString(2).padStart(cbits,'0'))
    .map((l,i)=>`<text x="${pad + i*cellW + cellW/2}" y="${pad-6}" text-anchor="middle" class="mono" font-size="12">${l||""}</text>`).join("");
  const rowLbl = Array.from({length:rows},(_,r)=> (gray(r)>>>0).toString(2).padStart(rbits,'0'))
    .map((l,i)=>`<text x="${pad-6}" y="${pad + i*cellH + cellH/2+4}" text-anchor="end" class="mono" font-size="12">${l||""}</text>`).join("");

  return `<div class="mono" style="margin:.5rem 0 .25rem">${title}</div>
  <svg viewBox="0 0 ${W} ${H}" width="100%" style="max-height:360px">
    <g fill="none" stroke="currentColor">${cells}${rects}</g>
    <g fill="currentColor">${colLbl}${rowLbl}</g>
  </svg>`;
}

async function showKmapGroups() {
  const text = exprEl.value.trim();
  if (!text) { alert("Type a kmap command or an expression."); return; }

  // Reuse your parser: accept either "kmap ..." or an expression
  let km = parseKmapCommand(text);
  let vars, minterms;
  if (km) {
    vars = km.vars;
    if (km.expr) {
      const r1 = await fetch(API + "/api/ba/simplify", {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ expr: km.expr, vars: km.vars, includeTable: false })
      });
      const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
      minterms = j1.minterms;
    } else {
      minterms = km.minterms;
    }
  } else {
    // Normal expr in box → compute mins from simplify; vars from input box if any
    vars = varsEl.value.trim() ? varsEl.value.split(",").map(s=>s.trim()) : undefined;
    const r1 = await fetch(API + "/api/ba/simplify", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ expr: text, vars, includeTable: false })
    });
    const j1 = await r1.json(); if (!j1.ok) throw new Error(j1.error||"simplify error");
    vars = j1.vars; minterms = j1.minterms;
  }

  // Ask backend for ALL groups + solution groups
  const r2 = await fetch(API + "/api/ba/kmap", {
    method:"POST", headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({ vars, minterms, full: true })
  });
  const j2 = await r2.json(); if (!j2.ok) { resEl.innerHTML = `<span class="muted">Error: ${j2.error}</span>`; return; }

  // Split: pairs only; solution groups (thicker stroke)
  const pairs = j2.allGroups.filter(g => g.hr*g.wr === 2);
  const solution = j2.solutionGroups;

  resEl.innerHTML =
    renderKmapSVG(vars, minterms, pairs, "All pairings (size 2)") +
    renderKmapSVG(vars, minterms, solution, `Solution groups → ${j2.simplified}`);
}

document.getElementById("btnKmapGroups")?.addEventListener("click", () => {
  ttCard.style.display="none"; ttEl.innerHTML="";
  resEl.textContent = "Analyzing K-map…";
  showKmapGroups().catch(e => resEl.innerHTML = `<span class="muted">Error: ${String(e.message||e)}</span>`);
});









  
</script>




  
</body>
</html>
